{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0},{"_id":"themes/next/source/js/search-toggle.js","path":"js/search-toggle.js","modified":0},{"_id":"themes/next/source/js/motion_global.js","path":"js/motion_global.js","modified":0},{"_id":"themes/next/source/js/motion_fallback.js","path":"js/motion_fallback.js","modified":0},{"_id":"themes/next/source/js/lazyload.js","path":"js/lazyload.js","modified":0},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":0},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":0},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0},{"_id":"themes/next/source/images/default_avatar.jpg","path":"images/default_avatar.jpg","modified":0},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","path":"images/bkdefault_avatar.jpg","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","path":"fonts/icon-linecons/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","path":"fonts/icon-linecons/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","path":"fonts/icon-linecons/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","path":"fonts/icon-linecons/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","path":"fonts/icon-icomoon/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","path":"fonts/icon-icomoon/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","path":"fonts/icon-icomoon/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","path":"fonts/icon-icomoon/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","path":"fonts/icon-fifty-shades/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","path":"fonts/icon-fifty-shades/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","path":"fonts/icon-fifty-shades/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","path":"fonts/icon-fifty-shades/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","path":"fonts/icon-feather/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","path":"fonts/icon-feather/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","path":"fonts/icon-feather/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","path":"fonts/icon-feather/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","path":"fonts/icon-default/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","path":"fonts/icon-default/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","path":"fonts/icon-default/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","path":"fonts/icon-default/icomoon.eot","modified":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0}],"Cache":[{"_id":"source/_posts/dockerfile.md","shasum":"2ecf4a16f49be089666a472d96dd6f7c9be810b8","modified":1446213015000},{"_id":"source/_posts/hello-world.md","shasum":"1398080a69852cddf2ecafdbce6469f552244db6","modified":1446555909000},{"_id":"source/_posts/front-end1.md","shasum":"fa8f2723ed02827c9593e6d7f9a1241e790e3d20","modified":1447676779000},{"_id":"source/_posts/jquery02.md","shasum":"ce1d9b351448986ca3c679d96bd0705f4d03180d","modified":1448281220000},{"_id":"source/_posts/jquery04.md","shasum":"3351784330820db122798ef8d8919ba90e3117a2","modified":1448281102000},{"_id":"source/_posts/jquery03.md","shasum":"7f41fc5162b81f9a4c6ec5440f828d8ac177941d","modified":1448022643000},{"_id":"source/_posts/jquery05.md","shasum":"bafa528fb21a2c7b8bf22094719cdaf58a68035f","modified":1448364290000},{"_id":"source/_posts/jquery01.md","shasum":"0bd17b8d4606a093477744dd327f950c034bbb0a","modified":1448281328000},{"_id":"source/_posts/jquery06.md","shasum":"3cd7cdabb304890e3e466e0da865be0659243ade","modified":1448457991000},{"_id":"source/_posts/jquery07.md","shasum":"9b283fb4dcfc13b1b303992382f584043bd9319b","modified":1448628957000},{"_id":"source/_posts/redux1.md","shasum":"0d03fd9a794cbec2121f3da0264a2507f926d802","modified":1446555735000},{"_id":"source/_posts/sublime2.md","shasum":"1566fd5d50e7813bbef2e0d79c0840abe3c8d4a2","modified":1446728337000},{"_id":"source/_posts/sublime1.md","shasum":"2838966721c5565772df0af69fce77f08517c634","modified":1446638045000},{"_id":"source/_posts/underscore02.md","shasum":"aa4af3e8175db9ddc8d7edf76681fac44d9baa0c","modified":1446033414000},{"_id":"source/tags/index.md","shasum":"e6199065e0feaab62cf16cd19b245475d7d5d77b","modified":1452934524000},{"_id":"source/_posts/url.md","shasum":"279b3198261dab37bdacd9af0ae76a5cd26514cd","modified":1447161408000},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437965515000},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437965515000},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437965515000},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437965515000},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437965515000},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437965515000},{"_id":"source/_posts/underscore03.md","shasum":"a84d600722f577cb7b33518ef9971ad9c977e80e","modified":1446123904000},{"_id":"source/_posts/underscore01.md","shasum":"2dc3ed3772033252b0631dbe04d35f8040978297","modified":1445950658000},{"_id":"themes/next/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1437965515000},{"_id":"themes/next/README.md","shasum":"aa16555d1aa1d80666ab9085042e118cdb7f5ef2","modified":1437965515000},{"_id":"themes/next/languages/default.yml","shasum":"d0cad2843283dd2a62cb8d1a2ed182a368210aca","modified":1437965515000},{"_id":"themes/next/bower.json","shasum":"1a681eeb5bff68be34e4e5226678c6cd3a7a12cc","modified":1437965515000},{"_id":"themes/next/languages/en.yml","shasum":"d0cad2843283dd2a62cb8d1a2ed182a368210aca","modified":1437965515000},{"_id":"themes/next/languages/fr-FR.yml","shasum":"9ee1011db6307df957684c83f39ac7499391924c","modified":1437965515000},{"_id":"themes/next/_config.yml","shasum":"965f15ca51ec0da7c55e6de502c7cb14c9ff0ddb","modified":1452934994000},{"_id":"themes/next/languages/de.yml","shasum":"784bea46de28a3113d7c91621740f521dae09dce","modified":1437965515000},{"_id":"themes/next/languages/ru.yml","shasum":"60cc1fb273adfd84137a207dd9d0d00f08605ccd","modified":1437965515000},{"_id":"themes/next/languages/zh-hk.yml","shasum":"e58766e0af5abf0705ccca4a5fc86d1be03db198","modified":1437965515000},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"282620a222ea32c062610f4ed6af016f862ccdfa","modified":1437965515000},{"_id":"themes/next/languages/zh-tw.yml","shasum":"d34c5781a231978e66852784ad00c9895a7de022","modified":1437965515000},{"_id":"themes/next/layout/_layout.swig","shasum":"417cc254ba47a77b43f6f45e398756a0a9a424e9","modified":1437965515000},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"939dbfc3de22706702da59e67293e1f243cbcf9f","modified":1437965515000},{"_id":"themes/next/layout/_partials/head.swig","shasum":"f2b7a6d43249622745a7d58daa11030f433d3c96","modified":1437965515000},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"e0e16ca56917b51728a13453d0a2f932da7ecdcb","modified":1437965515000},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1437965515000},{"_id":"themes/next/layout/_partials/header.swig","shasum":"c18888bd0a26f9bda3c6f7d17e22774a56f7378b","modified":1437965515000},{"_id":"themes/next/layout/_macro/post.swig","shasum":"9f3819f348a8a3af97c0fc520ea3944da5c3e4a9","modified":1437965515000},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"d6c7f04eee4388d8f133eb5526b7c0875c321a30","modified":1437965515000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"ee0c2540e8178f390051af7d365a42ae68375afa","modified":1437965515000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"94beb0764ccbbba0c9f5c9886cc656bf879bcfd5","modified":1437965515000},{"_id":"themes/next/layout/_partials/search.swig","shasum":"8a18d32e2a257dafaaba75353692db901e1dddc5","modified":1437965515000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1437965515000},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"b4b39dd010307ab61008a70a8ae9199ceeee89b5","modified":1437965515000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1437965515000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1437965515000},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"0ebbf76c2317faa8ba31365adba59331c2e0262c","modified":1437965515000},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1437965515000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1437965515000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1437965515000},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1437965515000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"3351ea62225933f8045d036a79654e19e84d19a7","modified":1437965515000},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"abc52fefb276c52cbb19de5c214521dfcf2a10fd","modified":1437965515000},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"817705bfd1a1282cb6bf59094afe507e11455aa0","modified":1437965515000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1437965515000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"b63ef233886538f30ced60344ac15d25e5f3e0af","modified":1437965515000},{"_id":"themes/next/layout/index.swig","shasum":"9fcae9769998e5f4182b363ccf3ae5a026728d50","modified":1437965515000},{"_id":"themes/next/layout/category.swig","shasum":"ca5b5b4c091e575487a398e5f1c0947fe3a13bfc","modified":1437965515000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1437965515000},{"_id":"themes/next/layout/archive.swig","shasum":"ed242c832d27743375a5fb524dc5a116a6a723a7","modified":1437965515000},{"_id":"themes/next/layout/post.swig","shasum":"3f3a183543cbb0d396484242952b02992366afef","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1437965515000},{"_id":"themes/next/layout/tag.swig","shasum":"f1dcfbc0eef76f1f6be29f31a343338d5bbfe814","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"c307f1e4827d7cb82816a5f9de109ae14ed4199c","modified":1437965515000},{"_id":"themes/next/layout/page.swig","shasum":"0b0924774a562ff45ed98e40c4e913df9a77fe08","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"fa6e23ebddb6f235803b51974f36be2a43b2c9c4","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"4b82dbbb6e536e6e8ee3cec6e62c2fd4bea60a09","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"54e73681ba6f57ef961138f94d2ee8ac845990c3","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1437965515000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"41a31d651b60b4f458fc56a1d191dfbbdcb6d794","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"8f9e8f5f65956ccf1d52ff8526392803dff579d3","modified":1437965515000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1437965515000},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"e79a08484b191dca14ccfc005053eb95786dafae","modified":1437965515000},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"be6c1a04595cf38673511366a3d89fcdb046f533","modified":1437965515000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"d776e241cf650b00ee1dd21b9ff377c250d9eeaa","modified":1437965515000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"f49f8966496166bd62f79f75a3277d4d5b1102e8","modified":1437965515000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1437965515000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"86bd4135afa2589ad074e0cf8ebb054ff3d10f24","modified":1437965515000},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1437965515000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"3874252c8392b5a18e849ac69b6d66999ec1de16","modified":1437965515000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"73796f6f13caa7151a2ee8e55755627e0d189f55","modified":1437965515000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"90e68936ea0f26af93c2c517fe1b891538f9c1b1","modified":1437965515000},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1437965515000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"6fd7caf8194656b90c3b7976295f157bce593b54","modified":1437965515000},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1437965515000},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1437965515000},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"ba501332fb111bd72dc0777f2e1c8a29ad538ff9","modified":1437965515000},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"4daaadd156ece64ae05908ad6bb0159c8a27c071","modified":1437965515000},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1437965515000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"d57e1769ebd2c472d2b27d17a706d3f564f94033","modified":1437965515000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"6259f4780f2aae1e6f85b892d8822c1c7ebc28bc","modified":1437965515000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1437965515000},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"66985fe77bd323f7f8f634908e17166f51e96e95","modified":1437965515000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"b0037a87ee1a613f315c331e8ecf1673c6d82211","modified":1437965515000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"05045d24850a982dc8069012c86c878b130b60eb","modified":1437965515000},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"68b6859fb48fe8358e567fc324f218cecfc3a533","modified":1437965515000},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"f5dda1ca48c1b73a0bd34e08413de57699f24083","modified":1437965515000},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"2588e55132e10d82c0608f03c2c72a2bace8fa4e","modified":1437965515000},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"59acc8bf6e6b55f576b001e520e048cd0ca801fb","modified":1437965515000},{"_id":"themes/next/source/css/main.styl","shasum":"b05c342e94ded24a5f2b203cedf77d3faa817fd5","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","shasum":"a58d5e893c6faefc90d5c2589cc314dff8ffca7a","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","shasum":"4f18f0bb815b1aeba57739069c3416106240b7c1","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","shasum":"4d0adc55240f331c6de225e23afd76ea5318da9c","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","shasum":"e6452f07b050ee0ff265b3b99a1e7ef82eb561b2","modified":1437965515000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","shasum":"6d0eb1a5bfef4f2bf77089bd090e88c5b2f7944d","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","shasum":"690836f81c0feb1a49e2253d4f984ad543414986","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","shasum":"8c865cffa3845be32406737fcc0466cf9cd965b3","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","shasum":"9159eea8641b840e0f7aa6e087dae414044ecdd3","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","shasum":"088a16303b0700e1c9e2c6962240b4c2f0fc3aa4","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","shasum":"f27c3643af6ed6f3d29a0be0c8dbea9b157857db","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","shasum":"e0b5e4a23a949bac499908bcef2fae56430e230e","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","shasum":"f0790da03008b6cb3ae4215cbb656cb4b4599633","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","shasum":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","shasum":"e316347805eb93425faa678611c5e42a7152da8f","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","shasum":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","shasum":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","shasum":"176695cc0dc12daba049b2bb889397a7bf2e553c","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","shasum":"c8ec218adabc788b17f976f60dd1c5fa872d9fc4","modified":1437965515000},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","shasum":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc","modified":1437965515000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1437965515000},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1437965515000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1437965515000},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1437965515000},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1437965515000},{"_id":"themes/next/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","shasum":"d1ed08a17670fa259df02c1d52dc9ce754343775","modified":1437965515000},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1437965515000},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1437965515000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1437965515000},{"_id":"themes/next/source/js/helpers.js","shasum":"c2117b0ec653df4c45dd9d9575b190cbe1035335","modified":1437965515000},{"_id":"themes/next/source/js/fancy-box.js","shasum":"116cafc741e048497287121a508d7a54c050c70c","modified":1437965515000},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"a7a618126d6853d52f4e32be116d3985325ad17d","modified":1437965515000},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1437965515000},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1437965515000},{"_id":"themes/next/source/js/motion_fallback.js","shasum":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1437965515000},{"_id":"themes/next/source/js/motion_global.js","shasum":"e6df9e7e61109667df0e22c4f7cc25c85015440b","modified":1437965515000},{"_id":"themes/next/source/js/search-toggle.js","shasum":"0bf617514cd86307f0678a226761341100dd86d4","modified":1437965515000},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1437965515000},{"_id":"themes/next/source/js/lazyload.js","shasum":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1437965515000},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1437965515000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1437965515000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1437965515000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1437965515000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1437965515000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","shasum":"888a285a4a7329210b2210742c673611c27425eb","modified":1437965515000},{"_id":"themes/next/tests/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1437965515000},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1437965515000},{"_id":"themes/next/tests/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1437965515000},{"_id":"themes/next/source/images/default_avatar.jpg","shasum":"6c5db2d64774e5a009853a915d163fa2f713e425","modified":1441025025000},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1437965515000},{"_id":"public/tags/index.html","modified":1452935026778,"shasum":"30d3a9b2c7928aa4a58ef741e1f7c4a620138a29"},{"_id":"public/categories/index.html","modified":1452934557857,"shasum":"656005e72c023346fbfbbdf152a6525533169175"},{"_id":"public/about/index.html","modified":1452934557918,"shasum":"36522a96754a831f15040a3f3e4447a06e5a321b"},{"_id":"public/2015/11/27/jquery07/index.html","modified":1452935026876,"shasum":"cc0b76bbb9c4dbbe5b38c70cbf70d2cea0a3453c"},{"_id":"public/2015/11/25/jquery06/index.html","modified":1452935026962,"shasum":"16f638441e4bb40dab5e16a998246c15e71e8f14"},{"_id":"public/2015/11/24/jquery05/index.html","modified":1452935027025,"shasum":"dce8c8af7a1c323ac0ed65469253c83d457d8189"},{"_id":"public/2015/11/23/jquery04/index.html","modified":1452935027094,"shasum":"60886178b7501199867bb5dbabaea9851fa23261"},{"_id":"public/2015/11/20/jquery03/index.html","modified":1452935027160,"shasum":"daaa8e60c87194dbe38c07e00d97ed3273e92803"},{"_id":"public/2015/11/19/jquery02/index.html","modified":1452935027227,"shasum":"0072d774955bf887be0af6d919b700db11656982"},{"_id":"public/2015/11/18/jquery01/index.html","modified":1452935027312,"shasum":"70b19e88d25667f9cca7abf420ead44cba6b45b2"},{"_id":"public/2015/11/16/front-end1/index.html","modified":1452935027379,"shasum":"0e007b0f7ab0ed1558df7847910dd356d8dae018"},{"_id":"public/2015/11/10/url/index.html","modified":1452935027439,"shasum":"bed7553735a108b92b5de530176f538a2a3083d6"},{"_id":"public/2015/11/05/sublime2/index.html","modified":1452935027497,"shasum":"1ecc4385a65f2e18be9ffdde667f81a351366a62"},{"_id":"public/2015/11/04/sublime1/index.html","modified":1452935027558,"shasum":"484d3504c35a9c215322b0fe4b90dac5a6669a6b"},{"_id":"public/2015/11/03/redux1/index.html","modified":1452935027602,"shasum":"c9cdab51dd9f63dca941ee1de258cf891c5315ba"},{"_id":"public/2015/10/30/dockerfile/index.html","modified":1452935027663,"shasum":"ce754de0909ecdc32f74248c641df135d7790d98"},{"_id":"public/2015/10/29/underscore03/index.html","modified":1452935027708,"shasum":"0d75d4dd49068641e3ae049304b268b15d2743af"},{"_id":"public/2015/10/28/underscore02/index.html","modified":1452935027764,"shasum":"736aa330730d347516e9b5eff77f31b209bfc296"},{"_id":"public/2015/10/27/underscore01/index.html","modified":1452935027812,"shasum":"00c61a29c37bdc706a30cc4d2f6ce97b42fb440d"},{"_id":"public/2014/10/17/hello-world/index.html","modified":1452935027865,"shasum":"a8ace22c1f2b81bd08e8e49d97b2b6c637f1e410"},{"_id":"public/archives/index.html","modified":1452935028056,"shasum":"6f57fcdacb73fc581e82786e0e043ad68c0b3051"},{"_id":"public/archives/page/2/index.html","modified":1452935028114,"shasum":"47c07be040ad2b5395d10b45fa487bcbb7ea1dea"},{"_id":"public/archives/2014/index.html","modified":1452935028163,"shasum":"6c9a12788aeaa2e139284e81fc14e7800aa16970"},{"_id":"public/archives/2014/10/index.html","modified":1452935028216,"shasum":"06171c7ddf86083bc4aed37465cc6747213b2094"},{"_id":"public/archives/2015/index.html","modified":1452935028282,"shasum":"77f8bfcb2f72a408cf935124b5304e46bcfb0807"},{"_id":"public/archives/2015/page/2/index.html","modified":1452935028317,"shasum":"c7182687cffe2fdec0f3cd49b37fc0225165574a"},{"_id":"public/archives/2015/10/index.html","modified":1452935028352,"shasum":"451ed0e539f6c9dd6a78fe265e40c28f310d09a1"},{"_id":"public/archives/2015/11/index.html","modified":1452935028397,"shasum":"2070c016733b3b4e2a2891e626f4a11866753cca"},{"_id":"public/archives/2015/11/page/2/index.html","modified":1452935028430,"shasum":"b3c782eae3122d459c9db61bbc69c689a4f2798e"},{"_id":"public/index.html","modified":1452935027946,"shasum":"5f74c7d3e2ff40cabc096dd5d6df50d0adfafebf"},{"_id":"public/page/2/index.html","modified":1452935028001,"shasum":"b5fed7bcd2c1fe1b40e09efa05798cb89900c5ac"},{"_id":"public/tags/hello/index.html","modified":1452935027892,"shasum":"4a79a0610417e82d44d9473ef09d0dbc0433fccc"}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2016-01-16T07:39:01.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2016-01-16 15:39:01\ntype: \"tags\"\n---\n","updated":"2016-01-16T08:55:24.000Z","path":"tags/index.html","_id":"cijgvit5b0001zp8g16j8oz2u","comments":1,"layout":"page"}],"Post":[{"title":"Docker - 关于Dockerfile的一些笔记","date":"2015-10-30T13:45:08.000Z","_content":"\nDocker 这种新的容器技术最近一年可谓热得发紫，前阵子去上海参加 PHP Conference China 2015 的时候，来自七牛的技术朋友在一个关于\"SaaS 产品交付探索\"的主题演讲中也介绍了 Docker。从上海回来之后，我开始尝试在自己的项目中使用 Docker 来搭建节省磁盘空间和扩展性良好的开发环境。\n\n​\n\n\n在 Docker 中，Dockerfile 是一个镜像的表示，使用 Dockerfile 可以允许用户创建自定义的镜像，通过 Dockerfile 来描述构建镜像的步骤，并自动构建一个容器。\n\n\n\n# 基本结构\n\n\n\nDockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。\n\n一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。\n\n<!-- more --> \n\n例如\n\n``` \n\n# This dockerfile uses the ubuntu image\n\n# VERSION 2 - EDITION 1\n\n# Author: docker_user\n\n# Command format: Instruction [arguments / command] ..\n\n\n\n# Base image to use, this must be set as the first line\n\nFROM ubuntu\n\n\n\n# Maintainer: docker_user <docker_user at email.com> (@docker_user)\n\nMAINTAINER docker_user docker_user@email.com\n\n\n\n# Commands to update the image\n\nRUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list\n\nRUN apt-get update && apt-get install -y nginx\n\nRUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf\n\n\n\n# Commands when creating a new container\n\nCMD /usr/sbin/nginx\n\n```\n\n其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。\n\n\n\n后面则是镜像操作指令，例如 RUN 指令，RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。\n\n\n\n最后是 CMD 指令，来指定运行容器时的操作命令。\n\n下面是一个更复杂的例子\n\n\n\n```\n\n# Nginx\n\n#\n\n# VERSION               0.0.1\n\n\n\nFROM      ubuntu\n\nMAINTAINER Victor Vieux <victor@docker.com>\n\n\n\nRUN apt-get update && apt-get install -y inotify-tools nginx apache2 openssh-server\n\n\n\n# Firefox over VNC\n\n#\n\n# VERSION               0.3\n\n\n\nFROM ubuntu\n\n\n\n# Install vnc, xvfb in order to create a 'fake' display and firefox\n\nRUN apt-get update && apt-get install -y x11vnc xvfb firefox\n\nRUN mkdir /.vnc\n\n# Setup a password\n\nRUN x11vnc -storepasswd 1234 ~/.vnc/passwd\n\n# Autostart firefox (might not be the best way, but it does the trick)\n\nRUN bash -c 'echo \"firefox\" >> /.bashrc'\n\n\n\nEXPOSE 5900\n\nCMD    [\"x11vnc\", \"-forever\", \"-usepw\", \"-create\"]\n\n\n\n# Multiple images example\n\n#\n\n# VERSION               0.1\n\n\n\nFROM ubuntu\n\nRUN echo foo > bar\n\n# Will output something like ===> 907ad6c2736f\n\n\n\nFROM ubuntu\n\nRUN echo moo > oink\n\n# Will output something like ===> 695d7793cbe4\n\n\n\n# You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with\n\n# /oink.\n\n```\n\n\n\n# 指令\n\n\n\n指令的一般格式为 INSTRUCTION arguments，指令包括 FROM、MAINTAINER、RUN 等。\n\n\n\n## FROM\n\n\n\n格式为 FROM `<image>` 或 FROM `<image>:<tag>` 。\n\n第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 FROM 指令（每个镜像一次）。\n\n\n\n## MAINTAINER\n\n\n\n格式为 MAINTAINER `<name>`，指定维护者信息。\n\n\n\n## RUN\n\n\n\n格式为 RUN `<command>` 或 RUN [\"executable\", \"param1\", \"param2\"]。\n\n\n\n前者将在 shell 终端中运行命令，即 /bin/sh -c；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 RUN [\"/bin/bash\", \"-c\", \"echo hello\"]。\n\n\n\n每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \\ 来换行。\n\n\n\n## CMD\n\n\n\n支持三种格式\n\n* CMD [\"executable\",\"param1\",\"param2\"] 使用 exec 执行，推荐方式；\n\n* CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；\n\n* CMD [\"param1\",\"param2\"] 提供给 ENTRYPOINT 的默认参数；\n\n\n\n指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。\n\n\n\n如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n\n\n\n## EXPOSE\n\n\n\n格式为 EXPOSE `<port> [<port>...]`。\n\n\n\n告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。\n\n\n\n## ENV\n\n\n\n格式为 ENV `<key> <value>`。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。\n\n\n\n例如\n\n```\n\nENV PG_MAJOR 9.3\n\nENV PG_VERSION 9.3.4\n\nRUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …\n\nENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH\n\n```\n\n\n\n## ADD\n\n\n\n格式为 ADD `<src> <dest>`。\n\n\n\n该命令将复制指定的 `<src>` 到容器中的 `<dest>`。 其中 `<src>` 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。\n\n\n\n## COPY\n\n\n\n格式为 COPY `<src> <dest>`。\n\n复制本地主机的 `<src>`（为 Dockerfile 所在目录的相对路径）到容器中的 `<dest>`。\n\n当使用本地目录为源目录时，推荐使用 COPY。\n\n\n\n## ENTRYPOINT\n\n\n\n两种格式：\n\n* ENTRYPOINT [\"executable\", \"param1\", \"param2\"]\n\n* ENTRYPOINT command param1 param2（shell中执行）。\n\n配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。\n\n每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。\n\n\n\n## VOLUME\n\n\n\n格式为 VOLUME [\"/data\"]。\n\n创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n\n\n\n## USER\n\n\n\n格式为 USER daemon。\n\n指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。\n\n当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：RUN groupadd -r postgres && useradd -r -g postgres postgres。要临时获取管理员权限可以使用 gosu，而不推荐 sudo。\n\n\n\n## WORKDIR\n\n\n\n格式为 WORKDIR /path/to/workdir。\n\n为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。\n\n可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\n\n例如\n\n```\n\nWORKDIR /a\n\nWORKDIR b\n\nWORKDIR c\n\nRUN pwd\n\n```\n\n则最终路径为 /a/b/c。\n\n\n\n## ONBUILD\n\n\n\n格式为 ONBUILD [INSTRUCTION]。\n\n配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。\n\n例如，Dockerfile 使用如下的内容创建了镜像 image-A。\n\n```\n\n[...]\n\nONBUILD ADD . /app/src\n\nONBUILD RUN /usr/local/bin/python-build --dir /app/src\n\n[...]\n\n```\n\n\n\n如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 FROM image-A\n\n指定基础镜像时，会自动执行ONBUILD 指令内容，等价于在后面添加了两条指令。\n\n\n\n```\n\nFROM image-A\n\n\n\n#Automatically run the following\n\nADD . /app/src\n\nRUN /usr/local/bin/python-build --dir /app/src\n\n```\n\n\n\n使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。","source":"_posts/dockerfile.md","raw":"title: Docker - 关于Dockerfile的一些笔记\ndate: 2015-10-30 21:45:08\ntags:\n---\n\nDocker 这种新的容器技术最近一年可谓热得发紫，前阵子去上海参加 PHP Conference China 2015 的时候，来自七牛的技术朋友在一个关于\"SaaS 产品交付探索\"的主题演讲中也介绍了 Docker。从上海回来之后，我开始尝试在自己的项目中使用 Docker 来搭建节省磁盘空间和扩展性良好的开发环境。\n\n​\n\n\n在 Docker 中，Dockerfile 是一个镜像的表示，使用 Dockerfile 可以允许用户创建自定义的镜像，通过 Dockerfile 来描述构建镜像的步骤，并自动构建一个容器。\n\n\n\n# 基本结构\n\n\n\nDockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。\n\n一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。\n\n<!-- more --> \n\n例如\n\n``` \n\n# This dockerfile uses the ubuntu image\n\n# VERSION 2 - EDITION 1\n\n# Author: docker_user\n\n# Command format: Instruction [arguments / command] ..\n\n\n\n# Base image to use, this must be set as the first line\n\nFROM ubuntu\n\n\n\n# Maintainer: docker_user <docker_user at email.com> (@docker_user)\n\nMAINTAINER docker_user docker_user@email.com\n\n\n\n# Commands to update the image\n\nRUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list\n\nRUN apt-get update && apt-get install -y nginx\n\nRUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf\n\n\n\n# Commands when creating a new container\n\nCMD /usr/sbin/nginx\n\n```\n\n其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。\n\n\n\n后面则是镜像操作指令，例如 RUN 指令，RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。\n\n\n\n最后是 CMD 指令，来指定运行容器时的操作命令。\n\n下面是一个更复杂的例子\n\n\n\n```\n\n# Nginx\n\n#\n\n# VERSION               0.0.1\n\n\n\nFROM      ubuntu\n\nMAINTAINER Victor Vieux <victor@docker.com>\n\n\n\nRUN apt-get update && apt-get install -y inotify-tools nginx apache2 openssh-server\n\n\n\n# Firefox over VNC\n\n#\n\n# VERSION               0.3\n\n\n\nFROM ubuntu\n\n\n\n# Install vnc, xvfb in order to create a 'fake' display and firefox\n\nRUN apt-get update && apt-get install -y x11vnc xvfb firefox\n\nRUN mkdir /.vnc\n\n# Setup a password\n\nRUN x11vnc -storepasswd 1234 ~/.vnc/passwd\n\n# Autostart firefox (might not be the best way, but it does the trick)\n\nRUN bash -c 'echo \"firefox\" >> /.bashrc'\n\n\n\nEXPOSE 5900\n\nCMD    [\"x11vnc\", \"-forever\", \"-usepw\", \"-create\"]\n\n\n\n# Multiple images example\n\n#\n\n# VERSION               0.1\n\n\n\nFROM ubuntu\n\nRUN echo foo > bar\n\n# Will output something like ===> 907ad6c2736f\n\n\n\nFROM ubuntu\n\nRUN echo moo > oink\n\n# Will output something like ===> 695d7793cbe4\n\n\n\n# You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with\n\n# /oink.\n\n```\n\n\n\n# 指令\n\n\n\n指令的一般格式为 INSTRUCTION arguments，指令包括 FROM、MAINTAINER、RUN 等。\n\n\n\n## FROM\n\n\n\n格式为 FROM `<image>` 或 FROM `<image>:<tag>` 。\n\n第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 FROM 指令（每个镜像一次）。\n\n\n\n## MAINTAINER\n\n\n\n格式为 MAINTAINER `<name>`，指定维护者信息。\n\n\n\n## RUN\n\n\n\n格式为 RUN `<command>` 或 RUN [\"executable\", \"param1\", \"param2\"]。\n\n\n\n前者将在 shell 终端中运行命令，即 /bin/sh -c；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 RUN [\"/bin/bash\", \"-c\", \"echo hello\"]。\n\n\n\n每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \\ 来换行。\n\n\n\n## CMD\n\n\n\n支持三种格式\n\n* CMD [\"executable\",\"param1\",\"param2\"] 使用 exec 执行，推荐方式；\n\n* CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；\n\n* CMD [\"param1\",\"param2\"] 提供给 ENTRYPOINT 的默认参数；\n\n\n\n指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。\n\n\n\n如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n\n\n\n## EXPOSE\n\n\n\n格式为 EXPOSE `<port> [<port>...]`。\n\n\n\n告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。\n\n\n\n## ENV\n\n\n\n格式为 ENV `<key> <value>`。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。\n\n\n\n例如\n\n```\n\nENV PG_MAJOR 9.3\n\nENV PG_VERSION 9.3.4\n\nRUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …\n\nENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH\n\n```\n\n\n\n## ADD\n\n\n\n格式为 ADD `<src> <dest>`。\n\n\n\n该命令将复制指定的 `<src>` 到容器中的 `<dest>`。 其中 `<src>` 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。\n\n\n\n## COPY\n\n\n\n格式为 COPY `<src> <dest>`。\n\n复制本地主机的 `<src>`（为 Dockerfile 所在目录的相对路径）到容器中的 `<dest>`。\n\n当使用本地目录为源目录时，推荐使用 COPY。\n\n\n\n## ENTRYPOINT\n\n\n\n两种格式：\n\n* ENTRYPOINT [\"executable\", \"param1\", \"param2\"]\n\n* ENTRYPOINT command param1 param2（shell中执行）。\n\n配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。\n\n每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。\n\n\n\n## VOLUME\n\n\n\n格式为 VOLUME [\"/data\"]。\n\n创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n\n\n\n## USER\n\n\n\n格式为 USER daemon。\n\n指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。\n\n当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：RUN groupadd -r postgres && useradd -r -g postgres postgres。要临时获取管理员权限可以使用 gosu，而不推荐 sudo。\n\n\n\n## WORKDIR\n\n\n\n格式为 WORKDIR /path/to/workdir。\n\n为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。\n\n可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\n\n例如\n\n```\n\nWORKDIR /a\n\nWORKDIR b\n\nWORKDIR c\n\nRUN pwd\n\n```\n\n则最终路径为 /a/b/c。\n\n\n\n## ONBUILD\n\n\n\n格式为 ONBUILD [INSTRUCTION]。\n\n配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。\n\n例如，Dockerfile 使用如下的内容创建了镜像 image-A。\n\n```\n\n[...]\n\nONBUILD ADD . /app/src\n\nONBUILD RUN /usr/local/bin/python-build --dir /app/src\n\n[...]\n\n```\n\n\n\n如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 FROM image-A\n\n指定基础镜像时，会自动执行ONBUILD 指令内容，等价于在后面添加了两条指令。\n\n\n\n```\n\nFROM image-A\n\n\n\n#Automatically run the following\n\nADD . /app/src\n\nRUN /usr/local/bin/python-build --dir /app/src\n\n```\n\n\n\n使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。","slug":"dockerfile","published":1,"updated":"2015-10-30T13:50:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit450000zp8gv3y1pfr0"},{"title":"从输入 URL 到页面加载完成的过程中都发生了什么","date":"2015-11-10T13:14:42.000Z","_content":"\n## 根据 URL 请求页面过程\n\n说实话，这类文章网上一抓一大把，而我仍想写这篇博客，一方面是想再仔细缕一下这个过程，另一方面是希望用清晰的语言和结构来解释，也算是小小地挑战一下自己。\n\n\n\n### 过程概述\n\n* 浏览器查找域名对应的 IP 地址；\n\n* 浏览器根据 IP 地址与服务器建立 socket 连接；\n\n* 浏览器与服务器通信： 浏览器请求，服务器处理请求；\n\n* 浏览器与服务器断开连接。\n\n\n\n天啦撸，结束了？也太简单了吧。。。各位看官，不急，都说了是概述，且向下看。\n\n<!-- more --> \n\n### 根据域名查找 IP 地址\n\n#### 概念解释\n\n* IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；\n\n* 域名（ DN ）：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）；\n\n* DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。\n\n\n\n知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）\n\n\n\n#### 查找过程\n\n* 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n\n* 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n\n* 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n\n* 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；\n\n  * LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；\n\n  * LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；\n\n  * LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；\n\n* LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；\n\n* 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n\n* 至此，浏览器已经得到了域名对应的 IP 地址。\n\n\n\n#### 补充说明\n\n* 域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，oulve.com 是我个人主页的域名，根据这个域名可以找到oulve的服务器，oulve.com/a/1 是 URL ，可以根据这个 URL 定位我写的第一篇博客；\n\n* IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；\n\n\n\n### 建立连接--三次握手\n\n知道了服务器的 IP 地址，下面便开始与服务器建立连接了。\n\n\n\n通俗地讲，通信连接的建立需要经历以下三个过程：\n\n* 主机向服务器发送一个建立连接的请求（**您好，我想认识您**）；\n\n* 服务器接到请求后发送同意连接的信号（**好的，很高兴认识您**）；\n\n* 主机接到同意连接的信号后，再次向服务器发送了确认信号（**我也很高兴认识您**），自此，主机与服务器两者建立了连接。\n\n\n\n#### 补充说明\n\n* TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。\n\n\n\n### 网页请求与显示\n\n当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。\n\n* 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n\n* 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n\n* 服务器将得到的 HTML 文件发送给浏览器；\n\n* 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n\n* 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n\n\n\n### 断开连接--四次挥手\n\n* 主机向服务器发送一个断开连接的请求（**不早了，我该走了**）；\n\n* 服务器接到请求后发送确认收到请求的信号（**知道了**）；\n\n* 服务器向主机发送断开通知（**我也该走了**）；\n\n* 主机接到断开通知后断开连接并反馈一个确认信号（**嗯，好的**），服务器收到确认信号后断开连接；\n\n\n\n#### 补充说明\n\n* 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。\n\n* 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。","source":"_posts/url.md","raw":"title: 从输入 URL 到页面加载完成的过程中都发生了什么\ndate: 2015-11-10 21:14:42\ntags:\n---\n\n## 根据 URL 请求页面过程\n\n说实话，这类文章网上一抓一大把，而我仍想写这篇博客，一方面是想再仔细缕一下这个过程，另一方面是希望用清晰的语言和结构来解释，也算是小小地挑战一下自己。\n\n\n\n### 过程概述\n\n* 浏览器查找域名对应的 IP 地址；\n\n* 浏览器根据 IP 地址与服务器建立 socket 连接；\n\n* 浏览器与服务器通信： 浏览器请求，服务器处理请求；\n\n* 浏览器与服务器断开连接。\n\n\n\n天啦撸，结束了？也太简单了吧。。。各位看官，不急，都说了是概述，且向下看。\n\n<!-- more --> \n\n### 根据域名查找 IP 地址\n\n#### 概念解释\n\n* IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；\n\n* 域名（ DN ）：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）；\n\n* DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。\n\n\n\n知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）\n\n\n\n#### 查找过程\n\n* 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n\n* 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n\n* 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n\n* 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；\n\n  * LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；\n\n  * LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；\n\n  * LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；\n\n* LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；\n\n* 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n\n* 至此，浏览器已经得到了域名对应的 IP 地址。\n\n\n\n#### 补充说明\n\n* 域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，oulve.com 是我个人主页的域名，根据这个域名可以找到oulve的服务器，oulve.com/a/1 是 URL ，可以根据这个 URL 定位我写的第一篇博客；\n\n* IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；\n\n\n\n### 建立连接--三次握手\n\n知道了服务器的 IP 地址，下面便开始与服务器建立连接了。\n\n\n\n通俗地讲，通信连接的建立需要经历以下三个过程：\n\n* 主机向服务器发送一个建立连接的请求（**您好，我想认识您**）；\n\n* 服务器接到请求后发送同意连接的信号（**好的，很高兴认识您**）；\n\n* 主机接到同意连接的信号后，再次向服务器发送了确认信号（**我也很高兴认识您**），自此，主机与服务器两者建立了连接。\n\n\n\n#### 补充说明\n\n* TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。\n\n\n\n### 网页请求与显示\n\n当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。\n\n* 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n\n* 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n\n* 服务器将得到的 HTML 文件发送给浏览器；\n\n* 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n\n* 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n\n\n\n### 断开连接--四次挥手\n\n* 主机向服务器发送一个断开连接的请求（**不早了，我该走了**）；\n\n* 服务器接到请求后发送确认收到请求的信号（**知道了**）；\n\n* 服务器向主机发送断开通知（**我也该走了**）；\n\n* 主机接到断开通知后断开连接并反馈一个确认信号（**嗯，好的**），服务器收到确认信号后断开连接；\n\n\n\n#### 补充说明\n\n* 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。\n\n* 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。","slug":"url","published":1,"updated":"2015-11-10T13:16:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5f0004zp8gl45kejj3"},{"title":"underscore源码通读（三）","date":"2015-10-29T13:02:14.000Z","_content":"\n后面的代码真是越看越难理解，经常需要结合内部/接口函数一起，所以采用跳读的方式解析，基本按照模块由易到难的顺序解析。\n\n\n\n```javascript\n\n456  _.initial = function(array, n, guard) {\n\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n\n};\n\n```\n\n\n\n这个guard参数说是保证默认返回第一个值，不过我看了很久觉得意义不大，猜测可能是以前的接口。这里的slice = Array.prototype.slice。这里有两个地方比较好，一是用Array的原型函数来处理array参数，这样可以避免判断array是否数组，二是用max来避免超出数组长度。\n\n<!-- more --> \n\n```javascript\n\n671 _.range = function(start, stop, step) {\n\n    if (arguments.length <= 1) {\n\n        stop = start || 0;\n\n        start = 0;\n\n    }\n\n    step = step || 1;\n\n\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n\n    var range = Array(length);\n\n\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n\n        range[idx] = start;\n\n    }\n\n\n\n    return range;\n\n};\n\n```\n\n\n\n这个函数本什没有什么特别的，只不过我在调用的时候将step赋值为小数，就出现了javascript著名的精度问题。网上应该有不少的解决方案，这里提供一种目前我在项目中用到的解决方法：将数字转为字符串在去小数点之后转为整数进行计算，计算完成后转字符串加上小数点再转成小数，举个例子\n\n\n\n```\n\n1.11 ==> \"1.11\" ==> \"111\" ==> 111\n\n2.2 ==> \"2.2\" ==> \"220\" ==> 220\n\n111+220 ==> 331 ==> \"331\" ==> \"3.31\" ==> 3.31\n\n```\n\n\n\n数组代码看得累了，从后面的看起吧~\n\n\n\n```javascript\n\n1269 _.noConflict = function() {\n\n    root._ = previousUnderscore;\n\n    return this;\n\n};\n\n```\n\n\n\n这个让渡函数其实原理比较简单，就是初始化underscore前 previousUnderscore=window._\n\n对原有对象进行储存，如果需要让渡避免冲突，则进行还原同时返回当前underscore对象。再来看看JQuery的实现原理：\n\n\n\n```javascript\n\nnoConflict: function( deep ) {\n\n    if ( window.$ === jQuery ) {\n\n        window.$ = _$;\n\n    }\n\n\n\n    if ( deep && window.jQuery === jQuery ) {\n\n        window.jQuery = _jQuery;\n\n    }\n\n\n\n    return jQuery;\n\n}\n\n```\n\n\n\n刚开始看的时候犯2了，函数可以用===来比较？不是只能比较简单的数据对象？呵呵，其实这个是通过引用地址来判断的，因为之前初始化的时候window.$=JQuery 所以$会指向JQuery的地址，所以可以这样判断。后面一个if考虑到JQuery这个变量名也被占用的时候，也进行让渡，最后返回JQuery对象。可能是考虑多版本的情况吧~\n\n\n\n```javascript\n\n1487  _.mixin = function(obj) {\n\n    _.each(_.functions(obj), function(name) {\n\n        var func = _[name] = obj[name];\n\n        _.prototype[name] = function() {\n\n            var args = [this._wrapped];\n\n            push.apply(args, arguments);\n\n            return result(this, func.apply(_, args));\n\n        };\n\n    });\n\n};\n\n\n\n// Add all of the Underscore functions to the wrapper object.\n\n_.mixin(_);\n\n```\n\n\n\n这个用于扩展underscore自身的接口函数，通过循环遍历对象来浅拷贝对象属性。这里考虑到函数的实例化，所以一方面将函数作为内部函数使用，同时扩展到prototype属性上。考虑得比较周全。\n\n\n\n```javascript\n\n1469  _.chain = function(obj) {\n\n    var instance = _(obj);\n\n    instance._chain = true;\n\n    return instance;\n\n};\n\n```\n\n\n\n这个函数让underscore支持链式调用，链式调用写起来很美观，但是调试略显不方便。结合之前的代码来看，underscore实现链式调用的基本原理是：将参数缓存在内部属性_wrapped中，调用函数时传入该属性值，执行后返回当前this指针。直到执行value函数时返回_wraped中的值。","source":"_posts/underscore03.md","raw":"title: underscore源码通读（三）\ndate: 2015-10-29 21:02:14\ntags:\n---\n\n后面的代码真是越看越难理解，经常需要结合内部/接口函数一起，所以采用跳读的方式解析，基本按照模块由易到难的顺序解析。\n\n\n\n```javascript\n\n456  _.initial = function(array, n, guard) {\n\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n\n};\n\n```\n\n\n\n这个guard参数说是保证默认返回第一个值，不过我看了很久觉得意义不大，猜测可能是以前的接口。这里的slice = Array.prototype.slice。这里有两个地方比较好，一是用Array的原型函数来处理array参数，这样可以避免判断array是否数组，二是用max来避免超出数组长度。\n\n<!-- more --> \n\n```javascript\n\n671 _.range = function(start, stop, step) {\n\n    if (arguments.length <= 1) {\n\n        stop = start || 0;\n\n        start = 0;\n\n    }\n\n    step = step || 1;\n\n\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n\n    var range = Array(length);\n\n\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n\n        range[idx] = start;\n\n    }\n\n\n\n    return range;\n\n};\n\n```\n\n\n\n这个函数本什没有什么特别的，只不过我在调用的时候将step赋值为小数，就出现了javascript著名的精度问题。网上应该有不少的解决方案，这里提供一种目前我在项目中用到的解决方法：将数字转为字符串在去小数点之后转为整数进行计算，计算完成后转字符串加上小数点再转成小数，举个例子\n\n\n\n```\n\n1.11 ==> \"1.11\" ==> \"111\" ==> 111\n\n2.2 ==> \"2.2\" ==> \"220\" ==> 220\n\n111+220 ==> 331 ==> \"331\" ==> \"3.31\" ==> 3.31\n\n```\n\n\n\n数组代码看得累了，从后面的看起吧~\n\n\n\n```javascript\n\n1269 _.noConflict = function() {\n\n    root._ = previousUnderscore;\n\n    return this;\n\n};\n\n```\n\n\n\n这个让渡函数其实原理比较简单，就是初始化underscore前 previousUnderscore=window._\n\n对原有对象进行储存，如果需要让渡避免冲突，则进行还原同时返回当前underscore对象。再来看看JQuery的实现原理：\n\n\n\n```javascript\n\nnoConflict: function( deep ) {\n\n    if ( window.$ === jQuery ) {\n\n        window.$ = _$;\n\n    }\n\n\n\n    if ( deep && window.jQuery === jQuery ) {\n\n        window.jQuery = _jQuery;\n\n    }\n\n\n\n    return jQuery;\n\n}\n\n```\n\n\n\n刚开始看的时候犯2了，函数可以用===来比较？不是只能比较简单的数据对象？呵呵，其实这个是通过引用地址来判断的，因为之前初始化的时候window.$=JQuery 所以$会指向JQuery的地址，所以可以这样判断。后面一个if考虑到JQuery这个变量名也被占用的时候，也进行让渡，最后返回JQuery对象。可能是考虑多版本的情况吧~\n\n\n\n```javascript\n\n1487  _.mixin = function(obj) {\n\n    _.each(_.functions(obj), function(name) {\n\n        var func = _[name] = obj[name];\n\n        _.prototype[name] = function() {\n\n            var args = [this._wrapped];\n\n            push.apply(args, arguments);\n\n            return result(this, func.apply(_, args));\n\n        };\n\n    });\n\n};\n\n\n\n// Add all of the Underscore functions to the wrapper object.\n\n_.mixin(_);\n\n```\n\n\n\n这个用于扩展underscore自身的接口函数，通过循环遍历对象来浅拷贝对象属性。这里考虑到函数的实例化，所以一方面将函数作为内部函数使用，同时扩展到prototype属性上。考虑得比较周全。\n\n\n\n```javascript\n\n1469  _.chain = function(obj) {\n\n    var instance = _(obj);\n\n    instance._chain = true;\n\n    return instance;\n\n};\n\n```\n\n\n\n这个函数让underscore支持链式调用，链式调用写起来很美观，但是调试略显不方便。结合之前的代码来看，underscore实现链式调用的基本原理是：将参数缓存在内部属性_wrapped中，调用函数时传入该属性值，执行后返回当前this指针。直到执行value函数时返回_wraped中的值。","slug":"underscore03","published":1,"updated":"2015-10-29T13:05:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5h0005zp8gb11hm49n"},{"title":"underscore源码通读（二）","date":"2015-10-28T11:55:11.000Z","_content":"\n先看一下两个比较重要的内部函数\n\n\n\n```javascript\n\n63 var optimizeCb = function(func, context, argCount) {\n\n    if (context === void 0) return func; \n\n    switch (argCount == null ? 3 : argCount) { \n\n        case 1: return function(value) { \n\n            return func.call(context, value); \n\n        }; \n\n        case 2: return function(value, other) { \n\n            return func.call(context, value, other); \n\n        }; \n\n        case 3: return function(value, index, collection) { \n\n            return func.call(context, value, index, collection); \n\n        }; \n\n        case 4: return function(accumulator, value, index, collection) { \n\n            return func.call(context, accumulator, value, index, collection); \n\n        }; \n\n    } \n\n    return function() { \n\n        return func.apply(context, arguments); \n\n    }; \n\n};\n\n```\n\n<!-- more --> \n\n这个函数是underscore内部很重要的函数，主要用来执行函数并改变所执行函数的作用域，最后加了一个argCount参数来指定参数个数，对参数个数小于等于4的情况进行分类处理。对不同参数的解释大概是：\n\n\n\n- 1的情况一般是用在接受单值的情况，比如times,sortedIndex之类的函数。\n\n- 2的情况据说是给比如jQuery,zepto事件绑定，代理什么的，但是在源代码中没有看到被调用。\n\n- 3的情况用于迭代器函数，比如foreach,map,pick等。\n\n- 4的情况用reduce和reduceRight函数。\n\n\n\n```javascript\n\n87 var cb = function(value, context, argCount) {\n\n    if (value == null) return _.identity;\n\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\n    if (_.isObject(value)) return _.matcher(value);\n\n    return _.property(value);\n\n};\n\n```\n\n\n\n这也是一个比较常用的内部函数，只是对参数进行了判断：如果是函数则返回上面说到的回调函数；如果是对象则返回一个能判断对象是否相等的函数；默认返回一个获取对象属性的函数。\n\n\n\n```javascript\n\n140 _.each = _.forEach = function(obj, iteratee, context) {\n\n    iteratee = optimizeCb(iteratee, context);\n\n    var i, length;\n\n    if (isArrayLike(obj)) {\n\n        for (i = 0, length = obj.length; i < length; i++) {\n\n            iteratee(obj[i], i, obj);\n\n        }\n\n    } else {\n\n        var keys = _.keys(obj);\n\n        for (i = 0, length = keys.length; i < length; i++) {\n\n            iteratee(obj[keys[i]], keys[i], obj);\n\n        }\n\n    }\n\n    \n\n    return obj;\n\n};\n\n\n\n// Return the results of applying the iteratee to each element.\n\n_.map = _.collect = function(obj, iteratee, context) {\n\n    iteratee = cb(iteratee, context);\n\n    var keys = !isArrayLike(obj) && _.keys(obj),\n\n    length = (keys || obj).length,\n\n    results = Array(length);\n\n    for (var index = 0; index < length; index++) {\n\n        var currentKey = keys ? keys[index] : index;\n\n        results[index] = iteratee(obj[currentKey], currentKey, obj);\n\n    }\n\n\n\n    return results;\n\n};\n\n```\n\n\n\n从代码上看，each函数是包括map函数的，map只能处理对象，each可以处理对象和数组。至于forEach和collect在API文档中看不到，应该是为了兼容以前老版本做的别名处理。\n\n\n\n```javascript\n\n170 function createReduce(dir) {\n\n    // Optimized iterator function as using arguments.length\n\n    // in the main function will deoptimize the, see #1991.\n\n    function iterator(obj, iteratee, memo, keys, index, length) {\n\n        for (; index >= 0 && index < length; index += dir) {\n\n            var currentKey = keys ? keys[index] : index;\n\n            memo = iteratee(memo, obj[currentKey], currentKey, obj);\n\n        }\n\n\n\n        return memo;\n\n    }\n\n\n\n    return function(obj, iteratee, memo, context) {\n\n        iteratee = optimizeCb(iteratee, context, 4);\n\n        var keys = !isArrayLike(obj) && _.keys(obj),\n\n        length = (keys || obj).length,\n\n        index = dir > 0 ? 0 : length - 1;\n\n        // Determine the initial value if none is provided.\n\n        if (arguments.length < 3) {\n\n            memo = obj[keys ? keys[index] : index];\n\n            index += dir;\n\n        }\n\n        \n\n        return iterator(obj, iteratee, memo, keys, index, length);\n\n    };\n\n}\n\n```\n\n\n\n这个是reduce和reduceRight调用的内部函数，将memo这个变量作为入参传递给iterator\n\n函数，调用自定义的iteratee函数进行循环处理，每次处理完的结果都赋值给memo变量，最后返回memo变量的结果。这里有两个问题\n\n\n\n- 为什么这里不按照常理逻辑来写代码而要用闭包呢？闭包大致有这么几个作用：避免命名冲突；私有化变量；变量持久化。这里的作用主要就是变量（函数）持久化，好处就是重复调用的时候不需要再重新创建函数，从而提升执行速度。\n\n- 为什么要用两层闭包呢？第一层闭包持久化iterator函数，调用reduce和reduceRight函数避免重复新建函数。第二层闭包保存keys,index,length这些变量。\n\n\n\n```javascript\n\n263 _.invoke = function(obj, method) {\n\n    var args = slice.call(arguments, 2);\n\n    var isFunc = _.isFunction(method);\n\n    return _.map(obj, function(value) {\n\n        var func = isFunc ? method : value[method];\n\n        return func == null ? func : func.apply(value, args);\n\n    });\n\n};\n\n```\n\n\n\n这里用slice.call(arguments, 2)来获取后面的不定参数，然后用func.apply(value, args)来传入该参数比较有意思。","source":"_posts/underscore02.md","raw":"title: underscore源码通读（二）\ndate: 2015-10-28 19:55:11\ntags:\n---\n\n先看一下两个比较重要的内部函数\n\n\n\n```javascript\n\n63 var optimizeCb = function(func, context, argCount) {\n\n    if (context === void 0) return func; \n\n    switch (argCount == null ? 3 : argCount) { \n\n        case 1: return function(value) { \n\n            return func.call(context, value); \n\n        }; \n\n        case 2: return function(value, other) { \n\n            return func.call(context, value, other); \n\n        }; \n\n        case 3: return function(value, index, collection) { \n\n            return func.call(context, value, index, collection); \n\n        }; \n\n        case 4: return function(accumulator, value, index, collection) { \n\n            return func.call(context, accumulator, value, index, collection); \n\n        }; \n\n    } \n\n    return function() { \n\n        return func.apply(context, arguments); \n\n    }; \n\n};\n\n```\n\n<!-- more --> \n\n这个函数是underscore内部很重要的函数，主要用来执行函数并改变所执行函数的作用域，最后加了一个argCount参数来指定参数个数，对参数个数小于等于4的情况进行分类处理。对不同参数的解释大概是：\n\n\n\n- 1的情况一般是用在接受单值的情况，比如times,sortedIndex之类的函数。\n\n- 2的情况据说是给比如jQuery,zepto事件绑定，代理什么的，但是在源代码中没有看到被调用。\n\n- 3的情况用于迭代器函数，比如foreach,map,pick等。\n\n- 4的情况用reduce和reduceRight函数。\n\n\n\n```javascript\n\n87 var cb = function(value, context, argCount) {\n\n    if (value == null) return _.identity;\n\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\n    if (_.isObject(value)) return _.matcher(value);\n\n    return _.property(value);\n\n};\n\n```\n\n\n\n这也是一个比较常用的内部函数，只是对参数进行了判断：如果是函数则返回上面说到的回调函数；如果是对象则返回一个能判断对象是否相等的函数；默认返回一个获取对象属性的函数。\n\n\n\n```javascript\n\n140 _.each = _.forEach = function(obj, iteratee, context) {\n\n    iteratee = optimizeCb(iteratee, context);\n\n    var i, length;\n\n    if (isArrayLike(obj)) {\n\n        for (i = 0, length = obj.length; i < length; i++) {\n\n            iteratee(obj[i], i, obj);\n\n        }\n\n    } else {\n\n        var keys = _.keys(obj);\n\n        for (i = 0, length = keys.length; i < length; i++) {\n\n            iteratee(obj[keys[i]], keys[i], obj);\n\n        }\n\n    }\n\n    \n\n    return obj;\n\n};\n\n\n\n// Return the results of applying the iteratee to each element.\n\n_.map = _.collect = function(obj, iteratee, context) {\n\n    iteratee = cb(iteratee, context);\n\n    var keys = !isArrayLike(obj) && _.keys(obj),\n\n    length = (keys || obj).length,\n\n    results = Array(length);\n\n    for (var index = 0; index < length; index++) {\n\n        var currentKey = keys ? keys[index] : index;\n\n        results[index] = iteratee(obj[currentKey], currentKey, obj);\n\n    }\n\n\n\n    return results;\n\n};\n\n```\n\n\n\n从代码上看，each函数是包括map函数的，map只能处理对象，each可以处理对象和数组。至于forEach和collect在API文档中看不到，应该是为了兼容以前老版本做的别名处理。\n\n\n\n```javascript\n\n170 function createReduce(dir) {\n\n    // Optimized iterator function as using arguments.length\n\n    // in the main function will deoptimize the, see #1991.\n\n    function iterator(obj, iteratee, memo, keys, index, length) {\n\n        for (; index >= 0 && index < length; index += dir) {\n\n            var currentKey = keys ? keys[index] : index;\n\n            memo = iteratee(memo, obj[currentKey], currentKey, obj);\n\n        }\n\n\n\n        return memo;\n\n    }\n\n\n\n    return function(obj, iteratee, memo, context) {\n\n        iteratee = optimizeCb(iteratee, context, 4);\n\n        var keys = !isArrayLike(obj) && _.keys(obj),\n\n        length = (keys || obj).length,\n\n        index = dir > 0 ? 0 : length - 1;\n\n        // Determine the initial value if none is provided.\n\n        if (arguments.length < 3) {\n\n            memo = obj[keys ? keys[index] : index];\n\n            index += dir;\n\n        }\n\n        \n\n        return iterator(obj, iteratee, memo, keys, index, length);\n\n    };\n\n}\n\n```\n\n\n\n这个是reduce和reduceRight调用的内部函数，将memo这个变量作为入参传递给iterator\n\n函数，调用自定义的iteratee函数进行循环处理，每次处理完的结果都赋值给memo变量，最后返回memo变量的结果。这里有两个问题\n\n\n\n- 为什么这里不按照常理逻辑来写代码而要用闭包呢？闭包大致有这么几个作用：避免命名冲突；私有化变量；变量持久化。这里的作用主要就是变量（函数）持久化，好处就是重复调用的时候不需要再重新创建函数，从而提升执行速度。\n\n- 为什么要用两层闭包呢？第一层闭包持久化iterator函数，调用reduce和reduceRight函数避免重复新建函数。第二层闭包保存keys,index,length这些变量。\n\n\n\n```javascript\n\n263 _.invoke = function(obj, method) {\n\n    var args = slice.call(arguments, 2);\n\n    var isFunc = _.isFunction(method);\n\n    return _.map(obj, function(value) {\n\n        var func = isFunc ? method : value[method];\n\n        return func == null ? func : func.apply(value, args);\n\n    });\n\n};\n\n```\n\n\n\n这里用slice.call(arguments, 2)来获取后面的不定参数，然后用func.apply(value, args)来传入该参数比较有意思。","slug":"underscore02","published":1,"updated":"2015-10-28T11:56:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5j0006zp8gmmrl7zov"},{"title":"underscore源码通读（一）","date":"2015-10-27T12:51:00.000Z","_content":"\n> underscore 源码版本 1.8.2\n\n\n\n# 起因\n\n\n\n很多人向我推荐研究js，可以看看一些第三方js类库的源码，而源码之中最好解读也最简短的就是underscore，它也是我平常比较喜欢的一个库，因为它性价比高：体积小、能力强。打开一看，才1000多行，试着读了一下，确实很值得一看，所以对精彩部分做了一下整理。\n\n\n\n# 闭包\n\n\n\n整个函数在一个闭包中，避免污染全局变量。通过传入this（其实就是window对象）来改变函数的作用域。和jquery的自执行函数其实是异曲同工之妙。这种传入全局变量的方式一方面有利于代码阅读，另一方面方便压缩。\n\n\n\nunderscore写法：\n\n```javascript\n\n(function(){ \n\n    ...\n\n}.call(this));\n\n```\n\n<!-- more --> \n\njquery写法：\n\n```javascript\n\n(function(window, undefined) { \n\n    ...\n\n})(window);\n\n```\n\n\n\n# 原型赋值\n\n\n\n```javascript\n\n18 var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n```\n\n\n\n`Array`,`Object`,`Function` 这些本质都是函数，获取函数原型属性prototype\n\n也是为了便于压缩。简单解释一下，如果代码中要扩展属性，可能这样写\n\n\n\n```javascript\n\nObject.prototype.xxx = ...\n\n```\n\n\n\n而这种代码是不可压缩的，Object,prototype这些名字改了浏览器就不认得了。\n\n\n\n但是上面的代码中创建了ObjProto之后，源生代码经过压缩之后，ObjProto就可能命名成a变量，那么原来的代码就压缩成\n\n\n\n```javascript\n\na.xxx = ...\n\n```\n\n\n\n一个小建议就是凡事一段代码被使用两次以上都建议定义变量(函数)，有利于修改和压缩代码。\n\n\n\n# 格式\n\n\n\n```javascript\n\n29 var\n\nnativeIsArray = Array.isArray,\n\nnativeKeys = Object.keys,\n\nnativeBind = FuncProto.bind,\n\nnativeCreate = Object.create;\n\n```\n\n\n\n这种定义的方式省略了多余的var，格式也美观，让我想到了sublime中的一个插件alignment。\n\n\n\n# 数据判断\n\n\n\n```javascript\n\n1194 _.isElement = function(obj) { \n\n    return !!(obj && obj.nodeType === 1); \n\n};\n\n```\n\n\n\n判断是否为dom，dom的nodeType属性值为1。这里用!!强转为boolean值\n\n\n\n```javascript\n\n1200 _.isArray = nativeIsArray || function(obj) { \n\n    return toString.call(obj) === '[object Array]'; \n\n};\n\n```\n\n\n\n判断是否为数组。由于Array.isArray函数是ECMAScript 5新增函数，所以为了兼容之前的版本，在原生判断函数不存在的情况下，后面重写了一个判断函数。用call函数来改变作用域可以避免当obj没有toString函数报错的情况。\n\n\n\n```javascript\n\n1205 _.isObject = function(obj) { \n\n    var type = typeof obj; \n\n    return type === 'function' || type === 'object' && !!obj;\n\n};\n\n```\n\n\n\n判断是否为对象。先用typeof判断数据类型。函数也属于对象，但是由于typeof null也是object，所以用!!obj来区分这种情况。\n\n\n\n```javascript\n\n1219 if (!_.isArguments(arguments)) {\n\n    _.isArguments = function(obj) { \n\n        return _.has(obj, 'callee');\n\n    };\n\n}\n\n```\n\n\n\n判断是否为arguments,很简单，arguments有个特有属性callee。\n\n\n\n```javascript\n\n1239 _.isNaN = function(obj) {\n\n    return _.isNumber(obj) && obj !== +obj; \n\n};\n\n```\n\n\n\nNaN这个值有两个特点：1.它是一个数；2.不等于它自己。\n\n\n\n‘+’放在变量前面一般作用是把后面的变量变成一个数，在这里已经判断为一个数仍加上’+’，是为了把var num = new Number()这种没有值的数字也归为NaN。\n\n\n\n```javascript\n\n1244 _.isBoolean = function(obj) {\n\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n\n};\n\n```\n\n\n\n是不是以为如果是布尔值不是true就是false？还有第3中情况var b = new Boolean()。b也是布尔值。\n\n\n\n```javascript\n\n1254 _.isUndefined = function(obj) {\n\n    return obj === void 0;\n\n};\n\n```\n\n\n\n用void 0来表示undefined，非常有意思的小技巧。不过常用方式还是if(xxx)来判断是不是undefined。\n\n\n\neq是underscore的一个内置函数，代码太长，不粘贴了。isEmpty调用了这个函数。整个思路由易到难，先用===比较简单数据，然后用toString来判断是否相等，最后用递归处理复杂的Array、Function和Object对象。\n\n\n\n```javascript\n\n1091 if (a === b) return a !== 0 || 1 / a === 1 / b;\n\n```\n\n\n\n这里为了区分’+0’和’-0’，因为这两个数对计算结果是有影响的。\n\n\n\n```javascript\n\nif (className !== toString.call(b)) return false;\n\nswitch (className) { \n\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value. \n\n    case '[object RegExp]': \n\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n\n    case '[object String]': \n\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is \n\n        // equivalent to `new String(\"5\")`. \n\n        return '' + a === '' + b; \n\n    case '[object Number]': \n\n        // `NaN`s are equivalent, but non-reflexive. \n\n        // Object(NaN) is equivalent to NaN if (+a !== +a) \n\n        return +b !== +b; \n\n        // An `egal` comparison is performed for other numeric values. \n\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b; \n\n    case '[object Date]': \n\n    case '[object Boolean]': \n\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their \n\n        // millisecond representations. Note that invalid dates with millisecond representations \n\n        // of `NaN` are not equivalent. \n\n        return +a === +b;\n\n}\n\n```\n\n\n\n这里是对简单对象进行判断，分为两类，一类是String和RegExp，这种数据直接toString然后判断。另一类是Number、Date和Boolean，通过转换成数字判断。\n\n\n\n```javascript\n\n1150 aStack.push(a);\n\nbStack.push(b);\n\nif (areArrays) { \n\n    length = a.length; \n\n    if (length !== b.length) return false; \n\n    while (length--) { \n\n        if (!eq(a[length], b[length], aStack, bStack)) return false; \n\n    }\n\n} else { \n\n    var keys = _.keys(a), key;\n\n    length = keys.length; \n\n    if (_.keys(b).length !== length) return false; \n\n    while (length--) { \n\n        key = keys[length]; \n\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;   \n\n    }\n\n}\n\naStack.pop();\n\nbStack.pop();\n\n```\n\n\n\n对于数组和对象只能用递归了，同时用aStack和bStack来暂存递归中的子对象。这里一个小技巧的就是先判断数组/属性的长度，如果不相等可以有效地减少递归。\n\n","source":"_posts/underscore01.md","raw":"title: underscore源码通读（一）\ndate: 2015-10-27 20:51:00\ntags:\n---\n\n> underscore 源码版本 1.8.2\n\n\n\n# 起因\n\n\n\n很多人向我推荐研究js，可以看看一些第三方js类库的源码，而源码之中最好解读也最简短的就是underscore，它也是我平常比较喜欢的一个库，因为它性价比高：体积小、能力强。打开一看，才1000多行，试着读了一下，确实很值得一看，所以对精彩部分做了一下整理。\n\n\n\n# 闭包\n\n\n\n整个函数在一个闭包中，避免污染全局变量。通过传入this（其实就是window对象）来改变函数的作用域。和jquery的自执行函数其实是异曲同工之妙。这种传入全局变量的方式一方面有利于代码阅读，另一方面方便压缩。\n\n\n\nunderscore写法：\n\n```javascript\n\n(function(){ \n\n    ...\n\n}.call(this));\n\n```\n\n<!-- more --> \n\njquery写法：\n\n```javascript\n\n(function(window, undefined) { \n\n    ...\n\n})(window);\n\n```\n\n\n\n# 原型赋值\n\n\n\n```javascript\n\n18 var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n```\n\n\n\n`Array`,`Object`,`Function` 这些本质都是函数，获取函数原型属性prototype\n\n也是为了便于压缩。简单解释一下，如果代码中要扩展属性，可能这样写\n\n\n\n```javascript\n\nObject.prototype.xxx = ...\n\n```\n\n\n\n而这种代码是不可压缩的，Object,prototype这些名字改了浏览器就不认得了。\n\n\n\n但是上面的代码中创建了ObjProto之后，源生代码经过压缩之后，ObjProto就可能命名成a变量，那么原来的代码就压缩成\n\n\n\n```javascript\n\na.xxx = ...\n\n```\n\n\n\n一个小建议就是凡事一段代码被使用两次以上都建议定义变量(函数)，有利于修改和压缩代码。\n\n\n\n# 格式\n\n\n\n```javascript\n\n29 var\n\nnativeIsArray = Array.isArray,\n\nnativeKeys = Object.keys,\n\nnativeBind = FuncProto.bind,\n\nnativeCreate = Object.create;\n\n```\n\n\n\n这种定义的方式省略了多余的var，格式也美观，让我想到了sublime中的一个插件alignment。\n\n\n\n# 数据判断\n\n\n\n```javascript\n\n1194 _.isElement = function(obj) { \n\n    return !!(obj && obj.nodeType === 1); \n\n};\n\n```\n\n\n\n判断是否为dom，dom的nodeType属性值为1。这里用!!强转为boolean值\n\n\n\n```javascript\n\n1200 _.isArray = nativeIsArray || function(obj) { \n\n    return toString.call(obj) === '[object Array]'; \n\n};\n\n```\n\n\n\n判断是否为数组。由于Array.isArray函数是ECMAScript 5新增函数，所以为了兼容之前的版本，在原生判断函数不存在的情况下，后面重写了一个判断函数。用call函数来改变作用域可以避免当obj没有toString函数报错的情况。\n\n\n\n```javascript\n\n1205 _.isObject = function(obj) { \n\n    var type = typeof obj; \n\n    return type === 'function' || type === 'object' && !!obj;\n\n};\n\n```\n\n\n\n判断是否为对象。先用typeof判断数据类型。函数也属于对象，但是由于typeof null也是object，所以用!!obj来区分这种情况。\n\n\n\n```javascript\n\n1219 if (!_.isArguments(arguments)) {\n\n    _.isArguments = function(obj) { \n\n        return _.has(obj, 'callee');\n\n    };\n\n}\n\n```\n\n\n\n判断是否为arguments,很简单，arguments有个特有属性callee。\n\n\n\n```javascript\n\n1239 _.isNaN = function(obj) {\n\n    return _.isNumber(obj) && obj !== +obj; \n\n};\n\n```\n\n\n\nNaN这个值有两个特点：1.它是一个数；2.不等于它自己。\n\n\n\n‘+’放在变量前面一般作用是把后面的变量变成一个数，在这里已经判断为一个数仍加上’+’，是为了把var num = new Number()这种没有值的数字也归为NaN。\n\n\n\n```javascript\n\n1244 _.isBoolean = function(obj) {\n\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n\n};\n\n```\n\n\n\n是不是以为如果是布尔值不是true就是false？还有第3中情况var b = new Boolean()。b也是布尔值。\n\n\n\n```javascript\n\n1254 _.isUndefined = function(obj) {\n\n    return obj === void 0;\n\n};\n\n```\n\n\n\n用void 0来表示undefined，非常有意思的小技巧。不过常用方式还是if(xxx)来判断是不是undefined。\n\n\n\neq是underscore的一个内置函数，代码太长，不粘贴了。isEmpty调用了这个函数。整个思路由易到难，先用===比较简单数据，然后用toString来判断是否相等，最后用递归处理复杂的Array、Function和Object对象。\n\n\n\n```javascript\n\n1091 if (a === b) return a !== 0 || 1 / a === 1 / b;\n\n```\n\n\n\n这里为了区分’+0’和’-0’，因为这两个数对计算结果是有影响的。\n\n\n\n```javascript\n\nif (className !== toString.call(b)) return false;\n\nswitch (className) { \n\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value. \n\n    case '[object RegExp]': \n\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n\n    case '[object String]': \n\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is \n\n        // equivalent to `new String(\"5\")`. \n\n        return '' + a === '' + b; \n\n    case '[object Number]': \n\n        // `NaN`s are equivalent, but non-reflexive. \n\n        // Object(NaN) is equivalent to NaN if (+a !== +a) \n\n        return +b !== +b; \n\n        // An `egal` comparison is performed for other numeric values. \n\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b; \n\n    case '[object Date]': \n\n    case '[object Boolean]': \n\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their \n\n        // millisecond representations. Note that invalid dates with millisecond representations \n\n        // of `NaN` are not equivalent. \n\n        return +a === +b;\n\n}\n\n```\n\n\n\n这里是对简单对象进行判断，分为两类，一类是String和RegExp，这种数据直接toString然后判断。另一类是Number、Date和Boolean，通过转换成数字判断。\n\n\n\n```javascript\n\n1150 aStack.push(a);\n\nbStack.push(b);\n\nif (areArrays) { \n\n    length = a.length; \n\n    if (length !== b.length) return false; \n\n    while (length--) { \n\n        if (!eq(a[length], b[length], aStack, bStack)) return false; \n\n    }\n\n} else { \n\n    var keys = _.keys(a), key;\n\n    length = keys.length; \n\n    if (_.keys(b).length !== length) return false; \n\n    while (length--) { \n\n        key = keys[length]; \n\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;   \n\n    }\n\n}\n\naStack.pop();\n\nbStack.pop();\n\n```\n\n\n\n对于数组和对象只能用递归了，同时用aStack和bStack来暂存递归中的子对象。这里一个小技巧的就是先判断数组/属性的长度，如果不相等可以有效地减少递归。\n\n","slug":"underscore01","published":1,"updated":"2015-10-27T12:57:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5k0007zp8ga99maurj"},{"title":"在SublimeText上搭建ReactJS开发环境","date":"2015-11-05T12:51:28.000Z","_content":"\n## 编辑器选择\n\n最近在学习ReactJS，这东西确实不错，但是在实际开发中却有很多问题。不是ReactJS本身的问题，而是开发环境，目前而言并没发现一个真正完美支持JSX语法的编辑器或IDE，这对于ReactJS开发者来说无疑是一个很头疼的事情，以往所习惯的码字方式都要改变，基本上要纯手打，虽然纯手打可以帮助记忆代码，但在工作效率上却就会大打折扣。\n\n\n\n### HBuilder\n\n之前一直用的是DCloud研发的[Hbuilder](http://www.dcloud.io/)来做WEB开发，可能很多人都不熟悉这个工具，简单说就是一个国产的WEB开发专用的IDE，集成了很多功能，习惯了之后工作效率确实提升不少。但Hbuilder在第三方插件方面比较弱，ReactJS的相关插件一个都没有，于是我只能换编辑器了。\n\n<!-- more --> \n\n### Atom\n\n现在的编辑器也很多，这里就不一一列举了。就目前我了解的来说，支持JSX语法高亮、代码提示以及代码校验的插件不多。Atom上有一个比较完善的ReactJS插件[ATOM REACT](http://orktes.github.io/atom-react/)，试用了一下，确实功能挺多，让我小激动了一下。但是Atom的性能却让我很不爽，首先是内存占用太大，我用的OSX，内存一下飙到900M+，一个IDE都没这么占内存。其次就是编辑较大的文件就会卡顿，那敲代码的延迟感简直不能忍，于是我放弃了Atom，可惜了这么好的一个插件。\n\n\n\n### SublimeText\n\n这个编辑器就不多说明了，做WEB开发的多少都了解一些，我之前用过一段时间的SublimeText，觉得找插件很麻烦，就投靠了可以一次搞定的HBuilder。现在重新启用了这个神器，因为我找到了几个很棒的ReactJS插件，下面就来具体说说。\n\n\n\n## SublimeText插件\n\n做ReactJS开发最需要的无疑是这两条：语法高亮、代码提示，如果能够想Emmet那样自动扩展就更好了，这里我可以告诉你，确实可以实现。\n\n\n\n### 语法高亮\n\n[Babel-Sublime](https://github.com/babel/babel-sublime)插件很好的支持了JSX语法的高亮显示，连包裹在组件中的HTML标签都能实现高亮显示，具体的插件安装以及设置方法就不多说了，自行看GitHub上的介绍吧，很简单。\n\n\n\n### 代码提示\n\n[Sublime-React](https://github.com/reactjs/sublime-react)插件严格的说并不是一个代码提示插件，而是一个类似于Emmet的自动扩展代码插件，只需要简单敲几个字母然后按下**TAB**键就能自动扩展成你想要的完整代码片段，效果如下图所示。\n\n\n\n![Sublime-React](http://7xnvp3.com1.z0.glb.clouddn.com/1055563878-563aee89c4438_articlex.gif)\n\n\n\n```\n\n//支持的代码片段如下\n\ncdm→  componentDidMount: fn() { ... }\n\ncdup→  componentDidUpdate: fn(pp, ps) { ... }\n\ncs→  var cx = React.addons.classSet;\n\ncwm→  componentWillMount: fn() { ... }\n\ncwr→  componentWillReceiveProps: fn(np) { ... }\n\ncwu→  componentWillUpdate: fn(np, ns) { ... }\n\ncwun→  componentWillUnmount: fn() { ... }\n\ncx→  cx({ ... })\n\nfdn→  React.findDOMNode(...)\n\nfup→  forceUpdate(...)\n\ngdp→  getDefaultProps: fn() { return {...} } \n\ngis→  getInitialState: fn() { return {...} } \n\nism→  isMounted()\n\nprops→  this.props.\n\npt→  propTypes { ... }\n\nrcc→  component skeleton\n\nrefs→  this.refs.\n\nren→  render: fn() { return ... }\n\nscu→  shouldComponentUpdate: fn(np, ns) { ... }\n\nsst→  this.setState({ ... })\n\nstate→  this.state.\n\n```\n\n\n\n### JSX中使用Emmet\n\n虽然上面这个插件可以实现JSX的代码扩展，但是在JSX中包裹的HTML却不能直接支持Emmet，需要通过安装其他插件以及修改相应设置来实现。首先是安装需要的插件：**RegReplace**和**Chain Of Command**，直接在插件库中搜索安装即可。接下来就是设置了，先在 `KeyBinding – Users` 中插入下面这段代码：\n\n```\n\n{\n\n    \"keys\": [\"tab\"],\n\n    \"command\": \"expand_abbreviation_by_tab\", \n\n    \"context\": [{\n\n        \"operand\": \"source.js\", \n\n        \"operator\": \"equal\", \n\n        \"match_all\": true, \n\n        \"key\": \"selector\"\n\n    },{\n\n        \"key\": \"preceding_text\", \n\n        \"operator\": \"regex_contains\", \n\n        \"operand\": \"(\\\\b(a\\\\b|div|span|p\\\\b|button)(\\\\.\\\\w*|>\\\\w*)?)\", \n\n        \"match_all\": true\n\n    },{\n\n        \"key\": \"selection_empty\", \n\n        \"operator\": \"equal\", \n\n        \"operand\": true, \n\n        \"match_all\": true\n\n    }]\n\n}\n\n```\n\n这样就实现了在JSX中按TAB键来扩展HTML片段了，但是JSX中的HTML和标准的HTML又有不同的地方，就是HTML中的 `class`，在JSX中是 `className`，所以这里就需要修改RegReplace的设置，找到 `Packagea Setting --> Reg Replace --> Settings-User`，插入下面这段代码：\n\n```\n\n{\n\n    \"replacements\": {\n\n        \"js_class\": {\n\n            \"find\": \" class=\\\"\",\n\n            \"replace\": \" className=\\\"\",\n\n            \"greedy\": true,\n\n            \"case\": false\n\n        }\n\n    }\n\n}\n\n```\n\n这样就大功告成了，开始快乐的学习ReactJS吧~~！欢迎各位大神来补充。","source":"_posts/sublime2.md","raw":"title: 在SublimeText上搭建ReactJS开发环境\ndate: 2015-11-05 20:51:28\ntags:\n---\n\n## 编辑器选择\n\n最近在学习ReactJS，这东西确实不错，但是在实际开发中却有很多问题。不是ReactJS本身的问题，而是开发环境，目前而言并没发现一个真正完美支持JSX语法的编辑器或IDE，这对于ReactJS开发者来说无疑是一个很头疼的事情，以往所习惯的码字方式都要改变，基本上要纯手打，虽然纯手打可以帮助记忆代码，但在工作效率上却就会大打折扣。\n\n\n\n### HBuilder\n\n之前一直用的是DCloud研发的[Hbuilder](http://www.dcloud.io/)来做WEB开发，可能很多人都不熟悉这个工具，简单说就是一个国产的WEB开发专用的IDE，集成了很多功能，习惯了之后工作效率确实提升不少。但Hbuilder在第三方插件方面比较弱，ReactJS的相关插件一个都没有，于是我只能换编辑器了。\n\n<!-- more --> \n\n### Atom\n\n现在的编辑器也很多，这里就不一一列举了。就目前我了解的来说，支持JSX语法高亮、代码提示以及代码校验的插件不多。Atom上有一个比较完善的ReactJS插件[ATOM REACT](http://orktes.github.io/atom-react/)，试用了一下，确实功能挺多，让我小激动了一下。但是Atom的性能却让我很不爽，首先是内存占用太大，我用的OSX，内存一下飙到900M+，一个IDE都没这么占内存。其次就是编辑较大的文件就会卡顿，那敲代码的延迟感简直不能忍，于是我放弃了Atom，可惜了这么好的一个插件。\n\n\n\n### SublimeText\n\n这个编辑器就不多说明了，做WEB开发的多少都了解一些，我之前用过一段时间的SublimeText，觉得找插件很麻烦，就投靠了可以一次搞定的HBuilder。现在重新启用了这个神器，因为我找到了几个很棒的ReactJS插件，下面就来具体说说。\n\n\n\n## SublimeText插件\n\n做ReactJS开发最需要的无疑是这两条：语法高亮、代码提示，如果能够想Emmet那样自动扩展就更好了，这里我可以告诉你，确实可以实现。\n\n\n\n### 语法高亮\n\n[Babel-Sublime](https://github.com/babel/babel-sublime)插件很好的支持了JSX语法的高亮显示，连包裹在组件中的HTML标签都能实现高亮显示，具体的插件安装以及设置方法就不多说了，自行看GitHub上的介绍吧，很简单。\n\n\n\n### 代码提示\n\n[Sublime-React](https://github.com/reactjs/sublime-react)插件严格的说并不是一个代码提示插件，而是一个类似于Emmet的自动扩展代码插件，只需要简单敲几个字母然后按下**TAB**键就能自动扩展成你想要的完整代码片段，效果如下图所示。\n\n\n\n![Sublime-React](http://7xnvp3.com1.z0.glb.clouddn.com/1055563878-563aee89c4438_articlex.gif)\n\n\n\n```\n\n//支持的代码片段如下\n\ncdm→  componentDidMount: fn() { ... }\n\ncdup→  componentDidUpdate: fn(pp, ps) { ... }\n\ncs→  var cx = React.addons.classSet;\n\ncwm→  componentWillMount: fn() { ... }\n\ncwr→  componentWillReceiveProps: fn(np) { ... }\n\ncwu→  componentWillUpdate: fn(np, ns) { ... }\n\ncwun→  componentWillUnmount: fn() { ... }\n\ncx→  cx({ ... })\n\nfdn→  React.findDOMNode(...)\n\nfup→  forceUpdate(...)\n\ngdp→  getDefaultProps: fn() { return {...} } \n\ngis→  getInitialState: fn() { return {...} } \n\nism→  isMounted()\n\nprops→  this.props.\n\npt→  propTypes { ... }\n\nrcc→  component skeleton\n\nrefs→  this.refs.\n\nren→  render: fn() { return ... }\n\nscu→  shouldComponentUpdate: fn(np, ns) { ... }\n\nsst→  this.setState({ ... })\n\nstate→  this.state.\n\n```\n\n\n\n### JSX中使用Emmet\n\n虽然上面这个插件可以实现JSX的代码扩展，但是在JSX中包裹的HTML却不能直接支持Emmet，需要通过安装其他插件以及修改相应设置来实现。首先是安装需要的插件：**RegReplace**和**Chain Of Command**，直接在插件库中搜索安装即可。接下来就是设置了，先在 `KeyBinding – Users` 中插入下面这段代码：\n\n```\n\n{\n\n    \"keys\": [\"tab\"],\n\n    \"command\": \"expand_abbreviation_by_tab\", \n\n    \"context\": [{\n\n        \"operand\": \"source.js\", \n\n        \"operator\": \"equal\", \n\n        \"match_all\": true, \n\n        \"key\": \"selector\"\n\n    },{\n\n        \"key\": \"preceding_text\", \n\n        \"operator\": \"regex_contains\", \n\n        \"operand\": \"(\\\\b(a\\\\b|div|span|p\\\\b|button)(\\\\.\\\\w*|>\\\\w*)?)\", \n\n        \"match_all\": true\n\n    },{\n\n        \"key\": \"selection_empty\", \n\n        \"operator\": \"equal\", \n\n        \"operand\": true, \n\n        \"match_all\": true\n\n    }]\n\n}\n\n```\n\n这样就实现了在JSX中按TAB键来扩展HTML片段了，但是JSX中的HTML和标准的HTML又有不同的地方，就是HTML中的 `class`，在JSX中是 `className`，所以这里就需要修改RegReplace的设置，找到 `Packagea Setting --> Reg Replace --> Settings-User`，插入下面这段代码：\n\n```\n\n{\n\n    \"replacements\": {\n\n        \"js_class\": {\n\n            \"find\": \" class=\\\"\",\n\n            \"replace\": \" className=\\\"\",\n\n            \"greedy\": true,\n\n            \"case\": false\n\n        }\n\n    }\n\n}\n\n```\n\n这样就大功告成了，开始快乐的学习ReactJS吧~~！欢迎各位大神来补充。","slug":"sublime2","published":1,"updated":"2015-11-05T12:58:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5l0008zp8gdbdw635o"},{"title":"我的 Sublime Text 必备插件","date":"2015-11-04T11:52:35.000Z","_content":"\n## 常用插件清单 :\n\n* SideBarEnhancements\n\n* HTML-CSS-JS Prettify\n\n* SublimeCodeIntel\n\n* Emmet\n\n\n\n## SideBarEnhancements\n\nSublime Text有一个缺点，当你想使用浏览器浏览你的html页面的时候，你需要在你的文件上点击鼠标右键，选择Open In Browser才可以浏览器浏览，而这是用默认浏览器浏览，如果想用第二个浏览器都没办法. 所以，可以通过SideBarEnhancements这个插件来更方便的浏览\n\n\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `sidebarenhancements` 安装\n\n\n\n### 第二步 : 配置 ( 一 )\n\n右键某html，js，css等文件，找到 `Open With` 然后点击 `Edit Applications`\n\n将里面内容设置为:\n\n<!-- more --> \n\n```\n\n[\n\n    {\"id\": \"side-bar-files-open-with\",\n\n        \"children\":\n\n        [\n\n\n\n            {\n\n                \"caption\": \"Firefox\",\n\n                \"id\": \"side-bar-files-open-with-chrome\",\n\n\n\n                \"command\": \"side_bar_files_open_with\",\n\n                \"args\": {\n\n                            \"paths\": [],\n\n                            \"application\": \"/Applications/Firefox.app\", \n\n                            //火狐浏览器的路径 Windows中，后缀为.exe\n\n                            \"extensions\":\".*\", \n\n                            \"args\":[]\n\n                        },\n\n                \"open_automatically\" : false \n\n            },\n\n\n\n            {\n\n                \"caption\": \"Chrome\",\n\n                \"id\": \"side-bar-files-open-with-chrome\",\n\n\n\n                \"command\": \"side_bar_files_open_with\",\n\n                \"args\": {\n\n                            \"paths\": [],\n\n                            \"application\": \"/Applications/Chrome.app\",\n\n                            //Chrome浏览器的路径 Windows中，后缀为.exe\n\n                            \"extensions\":\".*\", \n\n                            \"args\":[]\n\n                        },\n\n                \"open_automatically\" : false\n\n            },\n\n            \n\n            //如果想再添加浏览器，复制下面这个对象，改相应的路径就可以了.\n\n            {\n\n                \"caption\": \"Safari\",\n\n                \"id\": \"side-bar-files-open-with-chrome\",\n\n\n\n                \"command\": \"side_bar_files_open_with\",\n\n                \"args\": {\n\n                            \"paths\": [],\n\n                            \"application\": \"/Applications/Safari.app\",\n\n                            //Safari浏览器的路径 Windows中，后缀为.exe\n\n                            \"extensions\":\".*\", \n\n                            \"args\":[]\n\n                        },\n\n                \"open_automatically\" : false \n\n            }\n\n        \n\n            \n\n        ]\n\n    }\n\n]\n\n```\n\n\n\n### 第三步 : 配置 ( 二 )\n\n打开 `Preferences` 里面的 `Key Bindings - User` 把内容修改为:\n\n```\n\n//keys 对应的值就是按键，比如按F2就会用Firefox打开这个页面\n\n[\n\n    { \"keys\": [\"f2\"], \"command\": \"side_bar_files_open_with\",\n\n            \"args\": {\n\n                \"paths\": [],\n\n                \"application\": \"/Applications/Firefox.app\", \n\n                //对应上面的Firefox路径\n\n                \"extensions\":\".*\" \n\n            } \n\n    },\n\n\n\n    { \"keys\": [\"f1\"], \"command\": \"side_bar_files_open_with\",\n\n            \"args\": {\n\n                \"paths\": [],\n\n                \"application\": \"/Applications/Safari.app\",\n\n                //对应上面的Safari路径\n\n                \"extensions\":\".*\" \n\n            } \n\n    },\n\n    \n\n    //如果有新添加的浏览器，只需要把下面这个对象复制一份，路径与新添加的对应就可以了.\n\n    { \"keys\": [\"f4\"], \"command\": \"side_bar_files_open_with\",\n\n            \"args\": {\n\n                \"paths\": [],\n\n                \"application\": \"/Applications/Chrome.app\",\n\n                //对应上面的Chrome路径\n\n                \"extensions\":\".*\" \n\n            } \n\n    }\n\n]\n\n```\n\n现在，`F1` 就是 Safari，`F2` 是Firefox，`F4` 是 Chrome\n\n\n\n## HTML-CSS-JS Prettify\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `HTML-CSS-JS Prettify` 安装\n\n\n\n### 第二步 : 使用\n\n* 选中格式化代码，然后在按 `Cmd+Shift+H` (如果是Windows系统按 `Ctrl+Shift+H`，这两个快捷键是默认的).\n\n* 但是，这时候如果报错sh: node: command not found，说明node没有安装，那么就需要安装node. 安装好后，Linux和Mac不需要做什么更改，而Windows用户则需要配置一下node_path.\n\n* 首先，在菜单栏里点击Preferences点击第一个Browse Packages，然后进入HTML-CSS-JS Prettify文件夹，找到HTMLPrettify.sublime-settings文件，用Sublime Text打开进行更改windows对应的值，就是安装的node的路径\n\n\n\n### 第三步 : 配置 ( 快捷键 )\n\n如果对快捷键不满意，可以自己设置 . 打开 `Preferences` 里面的 `Key Bindings - User`，添加内容: `{ \"keys\": [\"alt+q\"], \"command\": \"htmlprettify\" }` ，当然快捷键你可以自己更改.\n\n\n\n### 第四步 : 配置 ( 代码整理样式 )\n\n如果对代码对其效果不满意，可以选择 `Preferences` 里的 `Package Settings` 找到 `HTML/CSS/JS Prettify` 里的 `Set Prettify Preferences` .里面是一些规则的设置. 这个文件就是github(详细设置可到github中看)中提到的.jsbeautifyrc文件\n\n\n\n## SublimeCodeIntel\n\n它的功能是代码提示，支持这些语言 : `JavaScript, Mason, XBL, XUL, RHTML, SCSS, Python, HTML, Ruby, Python3, XML, Sass, XSLT, Django,HTML5, Perl, CSS, Twig, Less, Smarty, Node.js, Tcl, TemplateToolkit, PHP` .\n\n\n\n它还有一个功能，就是跳转到函数定义的地方\n\n\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `SublimeCodeIntel` 安装.\n\n(安装过程中非常慢，慢慢等着吧，我挂了VPN快了不少)\n\n\n\n### 第二步 : 配置\n\n选择 `Preferences->Package Settings->SublimeCodeIntel->Setting Default`，将其内容全部复制到 `Setting User` 中 . 按 `Command+F` (或者 `ctrl+F` )搜索 `codeintel_selected_catalogs`，将其内容改为如下:\n\n```\n\n\"codeintel_selected_catalogs\": [\n\n  \"HTML5\", \"HTML\", \"JavaScript\"\n\n],\n\n```\n\n\n\n### 第三步 : 使用\n\n* 按 `d` 会提示 `div tag` 选择这个 `div tag` 就会出现 :\n\n```html\n\n<div></div>\n\n```\n\n\n\n但输入 `div.class` 或者 `div#id`，按下 `Tab` 会出现下面效果\n\n```html\n\n<div class=\"class\"></div>\n\n<div id=\"id\"></div>\n\n```\n\n\n\n这个功能2其实 `Emmet` 也有，但是 `Emmet` 没有功能1的代码提示\n\n\n\n## Emmet\n\n`Emmet` (前身为大名鼎鼎的 `Zen Coding` )是一个能大幅度提高前端开发效率的一个工具:\n\n\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `Emmet` 安装.\n\n\n\n### 第二步 : 使用\n\n快速设置 `class` 属性和 `id` 属性，在 `SublimeCodeIntel` 插件功能2就可以了，但是下面的功能 `SublimeCodeIntel` 却没有:\n\n输入 `ul>li*5`，按下 `Tab`，会有如下结果 :\n\n```html\n\n<ul>\n\n    <li></li>\n\n    <li></li>\n\n    <li></li>\n\n    <li></li>\n\n    <li></li>\n\n</ul>\n\n```\n\n\n\n更多使用方法可以 **百度**，**Google** 搜索这个插件怎么用，也可以去[官方文档](http://docs.emmet.io/)查看.\n\n\n\n### 第三步 : 配置\n\nEmmet还有一个功能，选取相同词，可以一次更改多个词，在mac中默认快捷键是 `Canmand+D` (我记得是，要不然我也不会改键).\n\n我习惯 `Cammand+D(Ctrl+d)` 是删除当前行，所以在 `Preferences->Key Bindings - User` 添加下面这两行:\n\n```\n\n{ \"keys\": [\"command+shift+d\"], \"command\":\"find_under_expand\" }, { \"keys\": [\"command+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} } // 修改过后，command+shift+d就是选取相同的词，command+d删除当前行\n\n```\n\n","source":"_posts/sublime1.md","raw":"title: 我的 Sublime Text 必备插件\ndate: 2015-11-04 19:52:35\ntags:\n---\n\n## 常用插件清单 :\n\n* SideBarEnhancements\n\n* HTML-CSS-JS Prettify\n\n* SublimeCodeIntel\n\n* Emmet\n\n\n\n## SideBarEnhancements\n\nSublime Text有一个缺点，当你想使用浏览器浏览你的html页面的时候，你需要在你的文件上点击鼠标右键，选择Open In Browser才可以浏览器浏览，而这是用默认浏览器浏览，如果想用第二个浏览器都没办法. 所以，可以通过SideBarEnhancements这个插件来更方便的浏览\n\n\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `sidebarenhancements` 安装\n\n\n\n### 第二步 : 配置 ( 一 )\n\n右键某html，js，css等文件，找到 `Open With` 然后点击 `Edit Applications`\n\n将里面内容设置为:\n\n<!-- more --> \n\n```\n\n[\n\n    {\"id\": \"side-bar-files-open-with\",\n\n        \"children\":\n\n        [\n\n\n\n            {\n\n                \"caption\": \"Firefox\",\n\n                \"id\": \"side-bar-files-open-with-chrome\",\n\n\n\n                \"command\": \"side_bar_files_open_with\",\n\n                \"args\": {\n\n                            \"paths\": [],\n\n                            \"application\": \"/Applications/Firefox.app\", \n\n                            //火狐浏览器的路径 Windows中，后缀为.exe\n\n                            \"extensions\":\".*\", \n\n                            \"args\":[]\n\n                        },\n\n                \"open_automatically\" : false \n\n            },\n\n\n\n            {\n\n                \"caption\": \"Chrome\",\n\n                \"id\": \"side-bar-files-open-with-chrome\",\n\n\n\n                \"command\": \"side_bar_files_open_with\",\n\n                \"args\": {\n\n                            \"paths\": [],\n\n                            \"application\": \"/Applications/Chrome.app\",\n\n                            //Chrome浏览器的路径 Windows中，后缀为.exe\n\n                            \"extensions\":\".*\", \n\n                            \"args\":[]\n\n                        },\n\n                \"open_automatically\" : false\n\n            },\n\n            \n\n            //如果想再添加浏览器，复制下面这个对象，改相应的路径就可以了.\n\n            {\n\n                \"caption\": \"Safari\",\n\n                \"id\": \"side-bar-files-open-with-chrome\",\n\n\n\n                \"command\": \"side_bar_files_open_with\",\n\n                \"args\": {\n\n                            \"paths\": [],\n\n                            \"application\": \"/Applications/Safari.app\",\n\n                            //Safari浏览器的路径 Windows中，后缀为.exe\n\n                            \"extensions\":\".*\", \n\n                            \"args\":[]\n\n                        },\n\n                \"open_automatically\" : false \n\n            }\n\n        \n\n            \n\n        ]\n\n    }\n\n]\n\n```\n\n\n\n### 第三步 : 配置 ( 二 )\n\n打开 `Preferences` 里面的 `Key Bindings - User` 把内容修改为:\n\n```\n\n//keys 对应的值就是按键，比如按F2就会用Firefox打开这个页面\n\n[\n\n    { \"keys\": [\"f2\"], \"command\": \"side_bar_files_open_with\",\n\n            \"args\": {\n\n                \"paths\": [],\n\n                \"application\": \"/Applications/Firefox.app\", \n\n                //对应上面的Firefox路径\n\n                \"extensions\":\".*\" \n\n            } \n\n    },\n\n\n\n    { \"keys\": [\"f1\"], \"command\": \"side_bar_files_open_with\",\n\n            \"args\": {\n\n                \"paths\": [],\n\n                \"application\": \"/Applications/Safari.app\",\n\n                //对应上面的Safari路径\n\n                \"extensions\":\".*\" \n\n            } \n\n    },\n\n    \n\n    //如果有新添加的浏览器，只需要把下面这个对象复制一份，路径与新添加的对应就可以了.\n\n    { \"keys\": [\"f4\"], \"command\": \"side_bar_files_open_with\",\n\n            \"args\": {\n\n                \"paths\": [],\n\n                \"application\": \"/Applications/Chrome.app\",\n\n                //对应上面的Chrome路径\n\n                \"extensions\":\".*\" \n\n            } \n\n    }\n\n]\n\n```\n\n现在，`F1` 就是 Safari，`F2` 是Firefox，`F4` 是 Chrome\n\n\n\n## HTML-CSS-JS Prettify\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `HTML-CSS-JS Prettify` 安装\n\n\n\n### 第二步 : 使用\n\n* 选中格式化代码，然后在按 `Cmd+Shift+H` (如果是Windows系统按 `Ctrl+Shift+H`，这两个快捷键是默认的).\n\n* 但是，这时候如果报错sh: node: command not found，说明node没有安装，那么就需要安装node. 安装好后，Linux和Mac不需要做什么更改，而Windows用户则需要配置一下node_path.\n\n* 首先，在菜单栏里点击Preferences点击第一个Browse Packages，然后进入HTML-CSS-JS Prettify文件夹，找到HTMLPrettify.sublime-settings文件，用Sublime Text打开进行更改windows对应的值，就是安装的node的路径\n\n\n\n### 第三步 : 配置 ( 快捷键 )\n\n如果对快捷键不满意，可以自己设置 . 打开 `Preferences` 里面的 `Key Bindings - User`，添加内容: `{ \"keys\": [\"alt+q\"], \"command\": \"htmlprettify\" }` ，当然快捷键你可以自己更改.\n\n\n\n### 第四步 : 配置 ( 代码整理样式 )\n\n如果对代码对其效果不满意，可以选择 `Preferences` 里的 `Package Settings` 找到 `HTML/CSS/JS Prettify` 里的 `Set Prettify Preferences` .里面是一些规则的设置. 这个文件就是github(详细设置可到github中看)中提到的.jsbeautifyrc文件\n\n\n\n## SublimeCodeIntel\n\n它的功能是代码提示，支持这些语言 : `JavaScript, Mason, XBL, XUL, RHTML, SCSS, Python, HTML, Ruby, Python3, XML, Sass, XSLT, Django,HTML5, Perl, CSS, Twig, Less, Smarty, Node.js, Tcl, TemplateToolkit, PHP` .\n\n\n\n它还有一个功能，就是跳转到函数定义的地方\n\n\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `SublimeCodeIntel` 安装.\n\n(安装过程中非常慢，慢慢等着吧，我挂了VPN快了不少)\n\n\n\n### 第二步 : 配置\n\n选择 `Preferences->Package Settings->SublimeCodeIntel->Setting Default`，将其内容全部复制到 `Setting User` 中 . 按 `Command+F` (或者 `ctrl+F` )搜索 `codeintel_selected_catalogs`，将其内容改为如下:\n\n```\n\n\"codeintel_selected_catalogs\": [\n\n  \"HTML5\", \"HTML\", \"JavaScript\"\n\n],\n\n```\n\n\n\n### 第三步 : 使用\n\n* 按 `d` 会提示 `div tag` 选择这个 `div tag` 就会出现 :\n\n```html\n\n<div></div>\n\n```\n\n\n\n但输入 `div.class` 或者 `div#id`，按下 `Tab` 会出现下面效果\n\n```html\n\n<div class=\"class\"></div>\n\n<div id=\"id\"></div>\n\n```\n\n\n\n这个功能2其实 `Emmet` 也有，但是 `Emmet` 没有功能1的代码提示\n\n\n\n## Emmet\n\n`Emmet` (前身为大名鼎鼎的 `Zen Coding` )是一个能大幅度提高前端开发效率的一个工具:\n\n\n\n### 第一步 : 安装\n\n通过 `Package Control->Install Package` 搜索 `Emmet` 安装.\n\n\n\n### 第二步 : 使用\n\n快速设置 `class` 属性和 `id` 属性，在 `SublimeCodeIntel` 插件功能2就可以了，但是下面的功能 `SublimeCodeIntel` 却没有:\n\n输入 `ul>li*5`，按下 `Tab`，会有如下结果 :\n\n```html\n\n<ul>\n\n    <li></li>\n\n    <li></li>\n\n    <li></li>\n\n    <li></li>\n\n    <li></li>\n\n</ul>\n\n```\n\n\n\n更多使用方法可以 **百度**，**Google** 搜索这个插件怎么用，也可以去[官方文档](http://docs.emmet.io/)查看.\n\n\n\n### 第三步 : 配置\n\nEmmet还有一个功能，选取相同词，可以一次更改多个词，在mac中默认快捷键是 `Canmand+D` (我记得是，要不然我也不会改键).\n\n我习惯 `Cammand+D(Ctrl+d)` 是删除当前行，所以在 `Preferences->Key Bindings - User` 添加下面这两行:\n\n```\n\n{ \"keys\": [\"command+shift+d\"], \"command\":\"find_under_expand\" }, { \"keys\": [\"command+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} } // 修改过后，command+shift+d就是选取相同的词，command+d删除当前行\n\n```\n\n","slug":"sublime1","published":1,"updated":"2015-11-04T11:54:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5n0009zp8gxq8kfwto"},{"title":"对 Redux 的梳理与理解","date":"2015-11-03T13:00:38.000Z","_content":"\n# Redux 介绍\n\n> 本文主要是对 [Redux 官方文档](http://rackt.github.io/redux/) 的梳理以及自身对 Redux 的理解。\n\n\n\n## 单页面应用的痛点\n\n对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。\n\n\n\nRedux 就是用来确保 state 变化的可预测性，主要的约束有：\n\n\n\n* state 以单一对象存储在 store 对象中\n\n* state 只读\n\n* 使用纯函数 reducer 执行 state 更新\n\n\n\n> state 为单一对象，使得 Redux 只需要维护一棵状态树，服务端很容易初始化状态，易于服务器渲染。state 只能通过 dispatch(action) 来触发更新，更新逻辑由 reducer 来执行。\n\n<!-- more -->\n\n## Actions、Reducers 和 Store\n\naction 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，比如: [Flux Standard Action](https://github.com/acdlite/flux-standard-action/)。 为了便于测试和易于扩展，Redux 引入了 Action Creator:\n\n```javascript\n\nfunction addTodo(text) {\n\n    return {\n\n        type: ADD_TODO,\n\n        text,\n\n    }\n\n}\n\nstore.dispatch(addTodo(text))\n\n```\n\n\n\n> dispatch(action) 是一个同步的过程：执行 reducer 更新 state -> 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。\n\n\n\nreducer 实际上就是一个函数：`(previousState, action) => newState`\n\n。用来执行根据指定 action 来更新 state 的逻辑。通过 combineReducers(reducers) 可以把多个 reducer 合并成一个 root reducer。\n\n\n\n> reducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象（可以考虑使用 [immutable-js](http://facebook.github.io/immutable-js/)）。\n\n\n\nstore 是一个单一对象：\n\n* 管理应用的 state\n\n* 通过 `store.getState()` 可以获取 state\n\n* 通过 `store.dispatch(action)` 来触发 state 更新\n\n* 通过 `store.subscribe(listener)` 来注册 state 变化监听器\n\n* 通过 `createStore(reducer, [initialState])` 创建\n\n\n\n> 在 Redux 应用中，只允许有一个 store 对象，可以通过 combineReducers(reducers) 来实现对 state 管理的逻辑划分（多个 reducer）。\n\n\n\n## Middleware\n\nmiddleware 其实就是高阶函数，作用于 dispatch 返回一个新的 dispatch（附加了该中间件功能）。可以形式化为：`newDispatch = middleware1(middleware2(...(dispatch)...))` 。\n\n```javascript\n\n// thunk-middleware\n\nexport default function thunkMiddleware({ dispatch, getState }) {\n\n    return next => action =>\n\n        typeof action === 'function' ? action(dispatch, getState) : next(action)\n\n}\n\n```\n\n\n\n通过 thunk-middleware 我们可以看出中间件的一般形式：中间件函数接受两个参数参数： dispatch 和 getState（也就是说中间件可以获取 state 以及 `dispatch new action`）。中间件一般返回 `next(action)`（thunk-middleware 比较特殊，它用于 dispatch 执行异步回调的 action）。store 的创建过程如下：\n\n```javascript\n\n// thunk-middleware\n\nconst reducer = combineReducers(reducers)\n\nconst finalCreateStore = applyMiddleware(promiseMiddleware, warningMiddleware,\n\n    loggerMiddleWare)(createStore)\n\nconst store = finalCreateStore(reducer)\n\n```\n\n\n\n## 异步 Actions\n\n单页面应用中充斥着大量的异步请求（ajax）。dispatch(action) 是同步的，如果要处理异步 action，需要使用一些中间件。 [redux-thunks](https://github.com/gaearon/redux-thunk/) 和 [redux-promise](https://github.com/aclite/redux-promise/) 分别是使用异步回调和 Promise 来解决异步 action 问题的。\n\n\n\n## Redux 和传统 Flux 框架的比较\n\n![Flux](http://7xnvp3.com1.z0.glb.clouddn.com/bVoR1E.jpg)\n\n![Redux](http://7xnvp3.com1.z0.glb.clouddn.com/bVoR1G.jpg)\n\n图来自 [UNIDIRECTIONAL USER INTERFACE ARCHITECTURES](http://staltz.com/unidirectional-user-interface-architectures.html)\n\n\n\n## Redux 和 React\n\nRedux 和 React 是没有必然关系的，Redux 用于管理 state，与具体的 View 框架无关。不过，Redux 特别适合那些 `state => UI` 的框架（比如：React, Deku）。\n\n\n\n> 简单来看：Smart component` 是连接 Redux 的组件（@connect），一般不可复用。Dumb component 是纯粹的组件，一般可复用。两者的共同点是：无状态，或者说状态提取到上层，统一由 redux 的 store 来管理。redux state -> Smart component -> Dumb component -> Dumb component（通过 props 传递）。在实践中，少量 Dumb component 允许自带 UI 状态信息（组件 unmount 后，不需要保留 UI 状态）。值得注意的是，Smart component 是应用更新状态的最小单元。实践中，可以将 route handlers 作为 Smart component，一个 Smart component 对应一个 reducer。","source":"_posts/redux1.md","raw":"title: 对 Redux 的梳理与理解\ndate: 2015-11-03 21:00:38\ntags:\n---\n\n# Redux 介绍\n\n> 本文主要是对 [Redux 官方文档](http://rackt.github.io/redux/) 的梳理以及自身对 Redux 的理解。\n\n\n\n## 单页面应用的痛点\n\n对于复杂的单页面应用，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。\n\n\n\nRedux 就是用来确保 state 变化的可预测性，主要的约束有：\n\n\n\n* state 以单一对象存储在 store 对象中\n\n* state 只读\n\n* 使用纯函数 reducer 执行 state 更新\n\n\n\n> state 为单一对象，使得 Redux 只需要维护一棵状态树，服务端很容易初始化状态，易于服务器渲染。state 只能通过 dispatch(action) 来触发更新，更新逻辑由 reducer 来执行。\n\n<!-- more -->\n\n## Actions、Reducers 和 Store\n\naction 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，比如: [Flux Standard Action](https://github.com/acdlite/flux-standard-action/)。 为了便于测试和易于扩展，Redux 引入了 Action Creator:\n\n```javascript\n\nfunction addTodo(text) {\n\n    return {\n\n        type: ADD_TODO,\n\n        text,\n\n    }\n\n}\n\nstore.dispatch(addTodo(text))\n\n```\n\n\n\n> dispatch(action) 是一个同步的过程：执行 reducer 更新 state -> 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。\n\n\n\nreducer 实际上就是一个函数：`(previousState, action) => newState`\n\n。用来执行根据指定 action 来更新 state 的逻辑。通过 combineReducers(reducers) 可以把多个 reducer 合并成一个 root reducer。\n\n\n\n> reducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象（可以考虑使用 [immutable-js](http://facebook.github.io/immutable-js/)）。\n\n\n\nstore 是一个单一对象：\n\n* 管理应用的 state\n\n* 通过 `store.getState()` 可以获取 state\n\n* 通过 `store.dispatch(action)` 来触发 state 更新\n\n* 通过 `store.subscribe(listener)` 来注册 state 变化监听器\n\n* 通过 `createStore(reducer, [initialState])` 创建\n\n\n\n> 在 Redux 应用中，只允许有一个 store 对象，可以通过 combineReducers(reducers) 来实现对 state 管理的逻辑划分（多个 reducer）。\n\n\n\n## Middleware\n\nmiddleware 其实就是高阶函数，作用于 dispatch 返回一个新的 dispatch（附加了该中间件功能）。可以形式化为：`newDispatch = middleware1(middleware2(...(dispatch)...))` 。\n\n```javascript\n\n// thunk-middleware\n\nexport default function thunkMiddleware({ dispatch, getState }) {\n\n    return next => action =>\n\n        typeof action === 'function' ? action(dispatch, getState) : next(action)\n\n}\n\n```\n\n\n\n通过 thunk-middleware 我们可以看出中间件的一般形式：中间件函数接受两个参数参数： dispatch 和 getState（也就是说中间件可以获取 state 以及 `dispatch new action`）。中间件一般返回 `next(action)`（thunk-middleware 比较特殊，它用于 dispatch 执行异步回调的 action）。store 的创建过程如下：\n\n```javascript\n\n// thunk-middleware\n\nconst reducer = combineReducers(reducers)\n\nconst finalCreateStore = applyMiddleware(promiseMiddleware, warningMiddleware,\n\n    loggerMiddleWare)(createStore)\n\nconst store = finalCreateStore(reducer)\n\n```\n\n\n\n## 异步 Actions\n\n单页面应用中充斥着大量的异步请求（ajax）。dispatch(action) 是同步的，如果要处理异步 action，需要使用一些中间件。 [redux-thunks](https://github.com/gaearon/redux-thunk/) 和 [redux-promise](https://github.com/aclite/redux-promise/) 分别是使用异步回调和 Promise 来解决异步 action 问题的。\n\n\n\n## Redux 和传统 Flux 框架的比较\n\n![Flux](http://7xnvp3.com1.z0.glb.clouddn.com/bVoR1E.jpg)\n\n![Redux](http://7xnvp3.com1.z0.glb.clouddn.com/bVoR1G.jpg)\n\n图来自 [UNIDIRECTIONAL USER INTERFACE ARCHITECTURES](http://staltz.com/unidirectional-user-interface-architectures.html)\n\n\n\n## Redux 和 React\n\nRedux 和 React 是没有必然关系的，Redux 用于管理 state，与具体的 View 框架无关。不过，Redux 特别适合那些 `state => UI` 的框架（比如：React, Deku）。\n\n\n\n> 简单来看：Smart component` 是连接 Redux 的组件（@connect），一般不可复用。Dumb component 是纯粹的组件，一般可复用。两者的共同点是：无状态，或者说状态提取到上层，统一由 redux 的 store 来管理。redux state -> Smart component -> Dumb component -> Dumb component（通过 props 传递）。在实践中，少量 Dumb component 允许自带 UI 状态信息（组件 unmount 后，不需要保留 UI 状态）。值得注意的是，Smart component 是应用更新状态的最小单元。实践中，可以将 route handlers 作为 Smart component，一个 Smart component 对应一个 reducer。","slug":"redux1","published":1,"updated":"2015-11-03T13:02:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5q000azp8g9luacl44"},{"title":"可想实现一个自己的简单jQuery库？(七)","date":"2015-11-27T12:54:43.000Z","_content":"\n## Lesson-6\n\n\n\n这个版本完善 hasClass 和 css 方法.\n\n\n\n新增 attr 和 data\n\n\n\n```javascript\n\ncss: function(attr, val) { //链式测试\n\n\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(typeof attr == 'string') {\n\n            if (arguments.length == 1) {\n\n                return getComputedStyle(this[0], null)[attr];\n\n            }\n\n            this[i].style[attr] = val;\n\n        } else {\n\n            var _this = this[i];\n\n            f.each(attr,function(attr,val) {\n\n                _this.style.cssText += '' + attr + ':' + val + ';';\n\n            });\n\n        }\n\n    }\n\n    return this;\n\n}\n\n```\n\n<!-- more -->\n\n在我们上一个版本中,没有对css方法传对象进行解析,在这我们要进行完善.\n\n\n\n刚刚好我们现在已经有了each方法!直接用上吧!\n\n\n\n在我们的for循环中,要先判断下传入的attr参数是字符串还是对象.\n\n\n\n如果是字符串,我们就按照 `css('width','100px')` 这样的方式处理\n\n\n\n如果是对象 `css({\"width\":'100px','height':'200px'})`\n\n```javascript\n\nvar _this = this[i];\n\nf.each(attr,function(attr,val) {\n\n    _this.style.cssText += '' + attr + ':' + val + ';';\n\n});\n\n```\n\n\n\n首先我们缓存下当前的this，然后用cssText方法，直接拼接进去即可.\n\n\n\n接着我们需要完善hasClass方法。这里要着重说明下！目前我搜到的一大堆hasClass方法与jQuery的实现都是不同的\n\n\n\n比如有这样的dom结构\n\n```html\n\n<div id=\"pox\">\n\n    <ul>\n\n        <li class=\"a c\">pox</li>\n\n        <li class=\"b\">pox</li>\n\n        <li>pox</li><li>pox</li>\n\n        <li>pox</li>\n\n    </ul>\n\n</div>\n\n```\n\n\n\n我们如果写 `$('#pox li').hasClass('b')` 与 `$('#pox li').hasClass('a')` 那都会是什么样的结果呢？\n\n\n\n结果是都会返回true。\n\n\n\n而现在基本能搜到的完全没有做这方面的判断。所以我们来看看我是如何实现的\n\n```javascript\n\nhasClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    var arr = [];\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].className.match(reg)) arr.push(true);\n\n            else arr.push(false);\n\n    }\n\n    if (arr.indexOf(true) != -1)  return true;\n\n        else  return false;\n\n}\n\n```\n\n\n\n首先我们需要一个正则匹配，还需要一个数组，进行存储每个元素是否有存在判断的class\n\n\n\n然后我们再在那个数组中寻找是否有true？如果有true，则返回true，如果一个true都没有的情况下，才能完全返回false。希望大家在这里要注意以下\n\n\n\n最后是我们的attr和data方法\n\n```javascript\n\nattr : function(attr, val) {\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(typeof attr == 'string') {\n\n            if (arguments.length == 1) {\n\n                return this[i].getAttribute(attr);\n\n            }\n\n            this[i].setAttribute(attr,val);\n\n        } else {\n\n            var _this = this[i];\n\n            f.each(attr,function(attr,val) {\n\n                _this.setAttribute(attr,val);;\n\n            });\n\n        }\n\n    }\n\n    return this;\n\n},\n\ndata : function(attr, val) {\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(typeof attr == 'string') {\n\n            if (arguments.length == 1) {\n\n                return this[i].getAttribute('data-' + attr);\n\n            }\n\n            this[i].setAttribute('data-' + attr,val);\n\n        } else {\n\n            var _this = this[i];\n\n            f.each(attr,function(attr,val) {\n\n                _this.setAttribute('data-' + attr,val);;\n\n            });\n\n        }\n\n    }\n\n    return this;\n\n}\n\n```\n\n\n\n这两个方法就很简单啦，跟CSS方法类似，先判断第一个参数是否为字符串，如果是字符串就是直接增加一个属性。如果是对象，就each下一个一个set即可。\n","source":"_posts/jquery07.md","raw":"title: 可想实现一个自己的简单jQuery库？(七)\ndate: 2015-11-27 20:54:43\ntags:\n---\n\n## Lesson-6\n\n\n\n这个版本完善 hasClass 和 css 方法.\n\n\n\n新增 attr 和 data\n\n\n\n```javascript\n\ncss: function(attr, val) { //链式测试\n\n\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(typeof attr == 'string') {\n\n            if (arguments.length == 1) {\n\n                return getComputedStyle(this[0], null)[attr];\n\n            }\n\n            this[i].style[attr] = val;\n\n        } else {\n\n            var _this = this[i];\n\n            f.each(attr,function(attr,val) {\n\n                _this.style.cssText += '' + attr + ':' + val + ';';\n\n            });\n\n        }\n\n    }\n\n    return this;\n\n}\n\n```\n\n<!-- more -->\n\n在我们上一个版本中,没有对css方法传对象进行解析,在这我们要进行完善.\n\n\n\n刚刚好我们现在已经有了each方法!直接用上吧!\n\n\n\n在我们的for循环中,要先判断下传入的attr参数是字符串还是对象.\n\n\n\n如果是字符串,我们就按照 `css('width','100px')` 这样的方式处理\n\n\n\n如果是对象 `css({\"width\":'100px','height':'200px'})`\n\n```javascript\n\nvar _this = this[i];\n\nf.each(attr,function(attr,val) {\n\n    _this.style.cssText += '' + attr + ':' + val + ';';\n\n});\n\n```\n\n\n\n首先我们缓存下当前的this，然后用cssText方法，直接拼接进去即可.\n\n\n\n接着我们需要完善hasClass方法。这里要着重说明下！目前我搜到的一大堆hasClass方法与jQuery的实现都是不同的\n\n\n\n比如有这样的dom结构\n\n```html\n\n<div id=\"pox\">\n\n    <ul>\n\n        <li class=\"a c\">pox</li>\n\n        <li class=\"b\">pox</li>\n\n        <li>pox</li><li>pox</li>\n\n        <li>pox</li>\n\n    </ul>\n\n</div>\n\n```\n\n\n\n我们如果写 `$('#pox li').hasClass('b')` 与 `$('#pox li').hasClass('a')` 那都会是什么样的结果呢？\n\n\n\n结果是都会返回true。\n\n\n\n而现在基本能搜到的完全没有做这方面的判断。所以我们来看看我是如何实现的\n\n```javascript\n\nhasClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    var arr = [];\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].className.match(reg)) arr.push(true);\n\n            else arr.push(false);\n\n    }\n\n    if (arr.indexOf(true) != -1)  return true;\n\n        else  return false;\n\n}\n\n```\n\n\n\n首先我们需要一个正则匹配，还需要一个数组，进行存储每个元素是否有存在判断的class\n\n\n\n然后我们再在那个数组中寻找是否有true？如果有true，则返回true，如果一个true都没有的情况下，才能完全返回false。希望大家在这里要注意以下\n\n\n\n最后是我们的attr和data方法\n\n```javascript\n\nattr : function(attr, val) {\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(typeof attr == 'string') {\n\n            if (arguments.length == 1) {\n\n                return this[i].getAttribute(attr);\n\n            }\n\n            this[i].setAttribute(attr,val);\n\n        } else {\n\n            var _this = this[i];\n\n            f.each(attr,function(attr,val) {\n\n                _this.setAttribute(attr,val);;\n\n            });\n\n        }\n\n    }\n\n    return this;\n\n},\n\ndata : function(attr, val) {\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(typeof attr == 'string') {\n\n            if (arguments.length == 1) {\n\n                return this[i].getAttribute('data-' + attr);\n\n            }\n\n            this[i].setAttribute('data-' + attr,val);\n\n        } else {\n\n            var _this = this[i];\n\n            f.each(attr,function(attr,val) {\n\n                _this.setAttribute('data-' + attr,val);;\n\n            });\n\n        }\n\n    }\n\n    return this;\n\n}\n\n```\n\n\n\n这两个方法就很简单啦，跟CSS方法类似，先判断第一个参数是否为字符串，如果是字符串就是直接增加一个属性。如果是对象，就each下一个一个set即可。\n","slug":"jquery07","published":1,"updated":"2015-11-27T12:55:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5t000bzp8gt00baka0"},{"title":"可想实现一个自己的简单jQuery库？(六)","date":"2015-11-25T13:19:45.000Z","_content":"\n## Lesson-5\n\n这个版本新增6个方法，find()、first()、last()、eq()、get()、ajax()\n\n\n\n```javascript\n\nfind : function(selector) {\n\n    if(!selector) return;\n\n    var context = this.selector;\n\n    return new Kodo(context + ' ' + selector);\n\n},\n```\n\n<!-- more -->\n\n```javascript\n\nfirst : function() {\n\n    return new Kodo(this[0])\n\n},\n```\n\n```javascript\nlast : function() {\n\n    var num = this.length - 1;\n\n    return new Kodo(this[num]);\n\n},\n```\n\n```javascript\neq : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return new Kodo(this[num]);\n\n},\n```\n\n```javascript\nget : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return this[num];\n\n}\n\n```\n\n\n\n我们要仔细分辨下，这4个方法在jQuery中返回的都是什么对象？到底是dom对象还是jQuery对象.\n\n\n\n明白了这个后就很容易能写出这4个方法\n\n```javascript\n\nfind : function(selector) {\n\n    if(!selector) return;\n\n    var context = this.selector;\n\n    return new Kodo(context + ' ' + selector);\n\n}\n\n```\n\n\n\n首先find，我们知道一般都会这样写 $('div').find('span') 查找div下的span，返回的是span数组对象，而不是原生的dom对象。\n\n\n\n那么我们就可以换个思路，因为我们能拿到 $('div') 这个selector对吧？也就是 div，既然又要find('span')，我们的selector就可以写成 ('div span')，之后直接返回新的数组对象不就好了吗？\n\n\n\n`var context = this.selector;` 先缓存当前的selector上下文，之后拼接我们find的selector，所以最后return 就变为 `new Kodo(context + ' ' + selector);` 虽然效率不一定高,总是一种解决思路不是吗？\n\n```javascript\n\nfirst : function() {\n\n    return new Kodo(this[0])\n\n},\n\nlast : function() {\n\n    var num = this.length - 1;\n\n    return new Kodo(this[num]);\n\n},\n\neq : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return new Kodo(this[num]);\n\n},\n\nget : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return this[num];\n\n}\n\n```\n\n\n\nfind方法比较难解决,之后这4个就很容易了，first、last、eq分别返回的都是封装后的对象，只有get返回的是原生 dom 对象。\n\n\n\n我们根据之前的思路,直接取数组对象的index，return下新的即可，是不是很简单？\n\n\n\n之后是ajax部分\n\n\n\n之前说过之所以，可以用$.ajax直接调用，是因为可以把方法直接挂在在构造函数上，作为静态方法，所以我们只需要写好ajax最后把你想要公开的接口放在Kodo上即可\n\n```javascript\n\nKodo.get = function(url,sucBack,complete) {\n\n    var options = {\n\n        url : url,\n\n        success : sucBack,\n\n        complete : complete\n\n    };\n\n    ajax(options);\n\n};\n\nKodo.post = function(url,data,sucback,complete) {\n\n    var options = {\n\n        url : url,\n\n        type : \"POST\",\n\n        data : data,\n\n        sucback    : sucback,\n\n        complete : complete\n\n    };\n\n    ajax(options);\n\n};\n\nfunction ajax(options) {\n\n    var defaultOptions = {\n\n        url: false, //ajax 请求地址\n\n        type : \"GET\",\n\n        data : false,\n\n        success: false, //数据成功返回后的回调方法\n\n        complete: false //ajax完成后的回调方法\n\n    };\n\n    for (i in defaultOptions) {\n\n        if (options[i] === undefined) {\n\n            options[i] = defaultOptions[i];\n\n        }\n\n    }\n\n    var xhr = new XMLHttpRequest();\n\n    var url = options.url;\n\n    xhr.open(options.type, url);\n\n    xhr.onreadystatechange = onStateChange;\n\n    if (options.type === 'POST') {\n\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n    }\n\n    xhr.send(options.data ? options.data : null);\n\n\n\n    function onStateChange() {\n\n        if (xhr.readyState == 4) {\n\n            var result,\n\n                status = xhr.status;\n\n\n\n            if ((status >= 200 && status < 300) || status == 304) {\n\n                result = xhr.responseText;\n\n                if (window.JSON) {\n\n                    result = JSON.parse(result);\n\n                } else {\n\n                    result = eval('(' + result + ')');\n\n                }\n\n                ajaxSuccess(result, xhr)\n\n            } else {\n\n                console.log(\"ERR\", xhr.status);\n\n            }\n\n        }\n\n    }\n\n    function ajaxSuccess(data, xhr) {\n\n        var status = 'success';\n\n        options.success && options.success(data, options, status, xhr)\n\n        ajaxComplete(status)\n\n    }\n\n    function ajaxComplete(status) {\n\n        options.complete && options.complete(status);\n\n    }\n\n}\n\n```\n\n\n\n在这我就不细讲ajax的具体过程，我也实现了一个比较简单的ajax，就公开了get和post方法。大家可以实现一个更加复杂好用的ajax替换我这段代码","source":"_posts/jquery06.md","raw":"title: 可想实现一个自己的简单jQuery库？(六)\ndate: 2015-11-25 21:19:45\ntags:\n---\n\n## Lesson-5\n\n这个版本新增6个方法，find()、first()、last()、eq()、get()、ajax()\n\n\n\n```javascript\n\nfind : function(selector) {\n\n    if(!selector) return;\n\n    var context = this.selector;\n\n    return new Kodo(context + ' ' + selector);\n\n},\n```\n\n<!-- more -->\n\n```javascript\n\nfirst : function() {\n\n    return new Kodo(this[0])\n\n},\n```\n\n```javascript\nlast : function() {\n\n    var num = this.length - 1;\n\n    return new Kodo(this[num]);\n\n},\n```\n\n```javascript\neq : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return new Kodo(this[num]);\n\n},\n```\n\n```javascript\nget : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return this[num];\n\n}\n\n```\n\n\n\n我们要仔细分辨下，这4个方法在jQuery中返回的都是什么对象？到底是dom对象还是jQuery对象.\n\n\n\n明白了这个后就很容易能写出这4个方法\n\n```javascript\n\nfind : function(selector) {\n\n    if(!selector) return;\n\n    var context = this.selector;\n\n    return new Kodo(context + ' ' + selector);\n\n}\n\n```\n\n\n\n首先find，我们知道一般都会这样写 $('div').find('span') 查找div下的span，返回的是span数组对象，而不是原生的dom对象。\n\n\n\n那么我们就可以换个思路，因为我们能拿到 $('div') 这个selector对吧？也就是 div，既然又要find('span')，我们的selector就可以写成 ('div span')，之后直接返回新的数组对象不就好了吗？\n\n\n\n`var context = this.selector;` 先缓存当前的selector上下文，之后拼接我们find的selector，所以最后return 就变为 `new Kodo(context + ' ' + selector);` 虽然效率不一定高,总是一种解决思路不是吗？\n\n```javascript\n\nfirst : function() {\n\n    return new Kodo(this[0])\n\n},\n\nlast : function() {\n\n    var num = this.length - 1;\n\n    return new Kodo(this[num]);\n\n},\n\neq : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return new Kodo(this[num]);\n\n},\n\nget : function(num) {\n\n    var num = num < 0 ? (this.length - 1) : num;\n\n    console.log(num);\n\n    return this[num];\n\n}\n\n```\n\n\n\nfind方法比较难解决,之后这4个就很容易了，first、last、eq分别返回的都是封装后的对象，只有get返回的是原生 dom 对象。\n\n\n\n我们根据之前的思路,直接取数组对象的index，return下新的即可，是不是很简单？\n\n\n\n之后是ajax部分\n\n\n\n之前说过之所以，可以用$.ajax直接调用，是因为可以把方法直接挂在在构造函数上，作为静态方法，所以我们只需要写好ajax最后把你想要公开的接口放在Kodo上即可\n\n```javascript\n\nKodo.get = function(url,sucBack,complete) {\n\n    var options = {\n\n        url : url,\n\n        success : sucBack,\n\n        complete : complete\n\n    };\n\n    ajax(options);\n\n};\n\nKodo.post = function(url,data,sucback,complete) {\n\n    var options = {\n\n        url : url,\n\n        type : \"POST\",\n\n        data : data,\n\n        sucback    : sucback,\n\n        complete : complete\n\n    };\n\n    ajax(options);\n\n};\n\nfunction ajax(options) {\n\n    var defaultOptions = {\n\n        url: false, //ajax 请求地址\n\n        type : \"GET\",\n\n        data : false,\n\n        success: false, //数据成功返回后的回调方法\n\n        complete: false //ajax完成后的回调方法\n\n    };\n\n    for (i in defaultOptions) {\n\n        if (options[i] === undefined) {\n\n            options[i] = defaultOptions[i];\n\n        }\n\n    }\n\n    var xhr = new XMLHttpRequest();\n\n    var url = options.url;\n\n    xhr.open(options.type, url);\n\n    xhr.onreadystatechange = onStateChange;\n\n    if (options.type === 'POST') {\n\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n    }\n\n    xhr.send(options.data ? options.data : null);\n\n\n\n    function onStateChange() {\n\n        if (xhr.readyState == 4) {\n\n            var result,\n\n                status = xhr.status;\n\n\n\n            if ((status >= 200 && status < 300) || status == 304) {\n\n                result = xhr.responseText;\n\n                if (window.JSON) {\n\n                    result = JSON.parse(result);\n\n                } else {\n\n                    result = eval('(' + result + ')');\n\n                }\n\n                ajaxSuccess(result, xhr)\n\n            } else {\n\n                console.log(\"ERR\", xhr.status);\n\n            }\n\n        }\n\n    }\n\n    function ajaxSuccess(data, xhr) {\n\n        var status = 'success';\n\n        options.success && options.success(data, options, status, xhr)\n\n        ajaxComplete(status)\n\n    }\n\n    function ajaxComplete(status) {\n\n        options.complete && options.complete(status);\n\n    }\n\n}\n\n```\n\n\n\n在这我就不细讲ajax的具体过程，我也实现了一个比较简单的ajax，就公开了get和post方法。大家可以实现一个更加复杂好用的ajax替换我这段代码","slug":"jquery06","published":1,"updated":"2015-11-25T13:26:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5w000czp8gfcsyo7i8"},{"title":"可想实现一个自己的简单jQuery库？(五)","date":"2015-11-24T11:22:05.000Z","_content":"\n## Lesson-4\n\n这个版本我们要增加一个用的非常多的方法!\n\n\n\n那就是each!\n\n\n\n我们知道each不仅能遍历数组，还能遍历对象.\n\n\n\n首先我们需要一个对数组进行验证的方法\n\n```javascript\n\nfunction isArray(obj) {\n\n    return Array.isArray(obj);\n\n}\n\n```\n\n<!-- more -->\n\n\n接着就是我们的重头戏\n\n```javascript\n\nKodo.each = function(obj,callback) {\n\n    var len = obj.length,\n\n        constru = obj.constructor,\n\n        i = 0;\n\n\n\n    if(constru === window.f) {\n\n        for (; i < len; i++) {\n\n            var val = callback.call(obj[i],i,obj[i]);\n\n            if(val === false) break;\n\n        }\n\n    } else if (isArray(obj)) {\n\n        for (; i < len; i++) {\n\n            var val = callback.call(obj[i],i,obj[i]);\n\n            if(val === false) break;\n\n        }\n\n    } else {\n\n        for( i in obj ) {\n\n            var val = callback.call(obj[i],i,obj[i]);\n\n            if(val === false) break;\n\n        }\n\n    }\n\n\n\n};\n\n```\n\n\n\n因为我们还可能遍历Kodo数组对象，如下：\n\n```javascript\n\nf(\"div\").each(function(index,item) {\n\n\n\n})\n\n```\n\n\n\n所以还需要一个判断 是否是Kodo数组对象\n\n```javascript\n\nif(constru === window.f) {\n\n    for (; i < len; i++) {\n\n        var val = callback.call(obj[i],i,obj[i]);\n\n        if(val === false) break;\n\n    }\n\n}\n\n```\n\n\n\n在这应该强调下call的用法，还是很多人不知道call何时使用.\n\n在我们的callback里 第一个参数是下标，第二个参数是当前的对象，然后this还要指向他自己\n\n所以 `callback.call(obj[i],i,obj[i]);` 就是这样写，第一个参数是改变this指向，第二个参数是下标，第三个是自己本身\n\n\n\n很简单不是吗?\n","source":"_posts/jquery05.md","raw":"title: 可想实现一个自己的简单jQuery库？(五)\ndate: 2015-11-24 19:22:05\ntags:\n---\n\n## Lesson-4\n\n这个版本我们要增加一个用的非常多的方法!\n\n\n\n那就是each!\n\n\n\n我们知道each不仅能遍历数组，还能遍历对象.\n\n\n\n首先我们需要一个对数组进行验证的方法\n\n```javascript\n\nfunction isArray(obj) {\n\n    return Array.isArray(obj);\n\n}\n\n```\n\n<!-- more -->\n\n\n接着就是我们的重头戏\n\n```javascript\n\nKodo.each = function(obj,callback) {\n\n    var len = obj.length,\n\n        constru = obj.constructor,\n\n        i = 0;\n\n\n\n    if(constru === window.f) {\n\n        for (; i < len; i++) {\n\n            var val = callback.call(obj[i],i,obj[i]);\n\n            if(val === false) break;\n\n        }\n\n    } else if (isArray(obj)) {\n\n        for (; i < len; i++) {\n\n            var val = callback.call(obj[i],i,obj[i]);\n\n            if(val === false) break;\n\n        }\n\n    } else {\n\n        for( i in obj ) {\n\n            var val = callback.call(obj[i],i,obj[i]);\n\n            if(val === false) break;\n\n        }\n\n    }\n\n\n\n};\n\n```\n\n\n\n因为我们还可能遍历Kodo数组对象，如下：\n\n```javascript\n\nf(\"div\").each(function(index,item) {\n\n\n\n})\n\n```\n\n\n\n所以还需要一个判断 是否是Kodo数组对象\n\n```javascript\n\nif(constru === window.f) {\n\n    for (; i < len; i++) {\n\n        var val = callback.call(obj[i],i,obj[i]);\n\n        if(val === false) break;\n\n    }\n\n}\n\n```\n\n\n\n在这应该强调下call的用法，还是很多人不知道call何时使用.\n\n在我们的callback里 第一个参数是下标，第二个参数是当前的对象，然后this还要指向他自己\n\n所以 `callback.call(obj[i],i,obj[i]);` 就是这样写，第一个参数是改变this指向，第二个参数是下标，第三个是自己本身\n\n\n\n很简单不是吗?\n","slug":"jquery05","published":1,"updated":"2015-11-24T11:24:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit5y000dzp8gh7hngu8j"},{"title":"可想实现一个自己的简单jQuery库？(四)","date":"2015-11-23T11:54:34.000Z","_content":"\n## Lesson-3\n\n修改f(selector) 里的判断,新增domReady\n\n我们知道在jQuery中还有一种选择器写法\n```javascript\n$(function() {\n\n});\n```\n\n在dom加载完毕后马上就执行,这样的方法会比onload更快,所以domReady对于我们来说一定是必不可少的\n\n<!-- more -->\n\n我们在init方法中要新增以下判断\n```javascript\nif(!selector) { return this; }\n\nif (typeof selector == 'object') {\n    var selector = [selector];\n    for (var i = 0; i < selector.length; i++) {\n        this[i] = selector[i];\n    }\n    this.length = selector.length;\n    return this;\n} else if (typeof selector == 'function') {\n    Kodo.ready(selector);\n    return;\n}\n```\n\n首先selector可能为object的情况,比如传入的是原生dom对象,dom数组对象. 另外要记得转为数组`var selector = [selector];\n\n因为有可能是一个元素比如是window,document等否则没法循环\n\n然后selector如果是function那我们就认为他是domReady\n\nPS:在这我判断的并没有非常的全面,仅仅具备了基础功能\n```javascript\nKodo.ready = function(fn) {\n    doc.addEventListener('DOMContentLoaded',function() {\n        fn && fn();\n    },false);\n    doc.removeEventListener('DOMContentLoaded',fn,true);\n};\n```\n\n然后这个是ready的源码,由于我们只兼容高端浏览器所以仅仅需要这样写即可.\n","source":"_posts/jquery04.md","raw":"title: 可想实现一个自己的简单jQuery库？(四)\ndate: 2015-11-23 19:54:34\ntags:\n---\n\n## Lesson-3\n\n修改f(selector) 里的判断,新增domReady\n\n我们知道在jQuery中还有一种选择器写法\n```javascript\n$(function() {\n\n});\n```\n\n在dom加载完毕后马上就执行,这样的方法会比onload更快,所以domReady对于我们来说一定是必不可少的\n\n<!-- more -->\n\n我们在init方法中要新增以下判断\n```javascript\nif(!selector) { return this; }\n\nif (typeof selector == 'object') {\n    var selector = [selector];\n    for (var i = 0; i < selector.length; i++) {\n        this[i] = selector[i];\n    }\n    this.length = selector.length;\n    return this;\n} else if (typeof selector == 'function') {\n    Kodo.ready(selector);\n    return;\n}\n```\n\n首先selector可能为object的情况,比如传入的是原生dom对象,dom数组对象. 另外要记得转为数组`var selector = [selector];\n\n因为有可能是一个元素比如是window,document等否则没法循环\n\n然后selector如果是function那我们就认为他是domReady\n\nPS:在这我判断的并没有非常的全面,仅仅具备了基础功能\n```javascript\nKodo.ready = function(fn) {\n    doc.addEventListener('DOMContentLoaded',function() {\n        fn && fn();\n    },false);\n    doc.removeEventListener('DOMContentLoaded',fn,true);\n};\n```\n\n然后这个是ready的源码,由于我们只兼容高端浏览器所以仅仅需要这样写即可.\n","slug":"jquery04","published":1,"updated":"2015-11-23T12:18:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit60000ezp8g347y4x5y"},{"title":"可想实现一个自己的简单jQuery库？(三)","date":"2015-11-20T12:26:15.000Z","_content":"\n## Lesson-2\n\n这个版本新增 next(),prev(),parent(),parents()\n\n\n\n这4个选择元素的方法还是比较常用的\n\n\n\n首先我们需要一个func来过滤我们需要的dom\n\n```javascript\n\nfunction sibling(cur, dir) {\n\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n\n}\n\n```\n\n<!-- more -->\n\n\n上面那段比较简单,就是普通的过滤下元素\n\n```javascript\n\nnext : function() {\n\n    return sibling(this[0], \"nextSibling\");\n\n},\n\nprev : function() {\n\n    return sibling(this[0], \"previousSibling\");\n\n},\n\n```\n\n\n\n看下next方法的源码就知道,我传入Kodo数组对象的0个dom对象,然后取它的下一个同辈元素,直接返回,prev方法同理\n\n```javascript\n\nparent : function() {\n\n    var parent = this[0].parentNode;\n\n    parent && parent.nodeType !== 11 ? parent : null;\n\n    var a = Kodo();\n\n        a[0] = parent;\n\n        a.selector = parent.tagName.toLocaleLowerCase();\n\n        a.length = 1;\n\n    return a;\n\n},\n\n```\n\n\n\n这段是取到第一个父元素,由于parent()返回的不是原生的DOM对象,是封装过的数组对象(Kodo),那我们就想办法构造一个新的Kodo对象即可\n\n\n\n所以我在里面var了一个 Kodo,然后设置这个Kodo数组对象的selector等配置,然后直接返回这个新的Kodo对象\n\n```javascript\n\nparents : function() {\n\n    var a = Kodo(),\n\n        i = 0;\n\n    while ( (this[0] = this[0][ 'parentNode' ]) && this[0].nodeType !== 9 ) {\n\n      if ( this[0].nodeType === 1 ) {\n\n        a[i] = this[0];\n\n        i++;\n\n      }\n\n    }\n\n    a.length = i;\n\n    return a;\n\n}\n\n```\n\n\n\n同理,在jQuery的parents方法中,返回的依旧是jQuery对象.我们依旧用上面的办法,构造一个新对象并且返回就好了!\n\n\n\n中间一层while循环,依次过滤出我们需要的dom元素,然后把他们都赋值到我们新var的对象里,最后别忘了设置一下新对象的length属性,返回我们的新对象即可!\n\n\n\n看了上面几个方法是不是觉得!其实很多时候我们完全可以自己新创建一个对象,然后配置好它直接返回这个新对象.比如find方法我们也可以用这样的办法:)","source":"_posts/jquery03.md","raw":"title: 可想实现一个自己的简单jQuery库？(三)\ndate: 2015-11-20 20:26:15\ntags:\n---\n\n## Lesson-2\n\n这个版本新增 next(),prev(),parent(),parents()\n\n\n\n这4个选择元素的方法还是比较常用的\n\n\n\n首先我们需要一个func来过滤我们需要的dom\n\n```javascript\n\nfunction sibling(cur, dir) {\n\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n\n}\n\n```\n\n<!-- more -->\n\n\n上面那段比较简单,就是普通的过滤下元素\n\n```javascript\n\nnext : function() {\n\n    return sibling(this[0], \"nextSibling\");\n\n},\n\nprev : function() {\n\n    return sibling(this[0], \"previousSibling\");\n\n},\n\n```\n\n\n\n看下next方法的源码就知道,我传入Kodo数组对象的0个dom对象,然后取它的下一个同辈元素,直接返回,prev方法同理\n\n```javascript\n\nparent : function() {\n\n    var parent = this[0].parentNode;\n\n    parent && parent.nodeType !== 11 ? parent : null;\n\n    var a = Kodo();\n\n        a[0] = parent;\n\n        a.selector = parent.tagName.toLocaleLowerCase();\n\n        a.length = 1;\n\n    return a;\n\n},\n\n```\n\n\n\n这段是取到第一个父元素,由于parent()返回的不是原生的DOM对象,是封装过的数组对象(Kodo),那我们就想办法构造一个新的Kodo对象即可\n\n\n\n所以我在里面var了一个 Kodo,然后设置这个Kodo数组对象的selector等配置,然后直接返回这个新的Kodo对象\n\n```javascript\n\nparents : function() {\n\n    var a = Kodo(),\n\n        i = 0;\n\n    while ( (this[0] = this[0][ 'parentNode' ]) && this[0].nodeType !== 9 ) {\n\n      if ( this[0].nodeType === 1 ) {\n\n        a[i] = this[0];\n\n        i++;\n\n      }\n\n    }\n\n    a.length = i;\n\n    return a;\n\n}\n\n```\n\n\n\n同理,在jQuery的parents方法中,返回的依旧是jQuery对象.我们依旧用上面的办法,构造一个新对象并且返回就好了!\n\n\n\n中间一层while循环,依次过滤出我们需要的dom元素,然后把他们都赋值到我们新var的对象里,最后别忘了设置一下新对象的length属性,返回我们的新对象即可!\n\n\n\n看了上面几个方法是不是觉得!其实很多时候我们完全可以自己新创建一个对象,然后配置好它直接返回这个新对象.比如find方法我们也可以用这样的办法:)","slug":"jquery03","published":1,"updated":"2015-11-20T12:30:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit62000fzp8gigel3wxn"},{"title":"可想实现一个自己的简单jQuery库？(二)","date":"2015-11-19T12:25:12.000Z","_content":"\n## Lesson-1 初步体验\n\n这个版本呢,先来加四个很简单的方法感受感受下!\n\n\n\n首先3个class不用说了\n\n```javascript\n\nhasClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].className.match(reg)) return true;\n\n            return false;\n\n    }\n\n    return this;\n\n},\n\n```\n\n<!-- more -->\n\n```javascript\naddClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(!this[i].className.match(reg))\n\n            this[i].className += ' ' + cls;\n\n    }\n\n    return this;\n\n},\n```\n\n\n\n```javascript\n\nremoveClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].className.match(reg))\n\n            this[i].className = this[i].className.replace(' ' + cls,'');\n\n    }\n\n    return this;\n\n}\n\n```\n\n<!-- more -->\n\n然后新增一个\n\n```javascript\n\ncss : function(attr,val) { // 链式测试\n\n    console.log(this.length);\n\n    for(var i = 0;i < this.length; i++) {\n\n        if(arguments.length == 1) {\n\n            return getComputedStyle(this[i],null)[attr];\n\n        }\n\n        this[i].style[attr] = val;\n\n    }\n\n    return this;\n\n}\n\n```\n\n\n\n这些其实都很简单,我们都要记住,我们封装的DOM对象是一个数组,所以一定都需要用循环来进行各种个样的处理\n\n\n\n然后css这我是用 `arguments` 的个数来进行判断是取值还是设值\n\n\n\n最后千万别忘了每个方法的最后都要 `return this` 以便链式调用\n\n\n\n大家可以自行拿这几个方法 log出来看看是否是与jQuery的一样就知道是否成功了\n","source":"_posts/jquery02.md","raw":"title: 可想实现一个自己的简单jQuery库？(二)\ndate: 2015-11-19 20:25:12\ntags:\n---\n\n## Lesson-1 初步体验\n\n这个版本呢,先来加四个很简单的方法感受感受下!\n\n\n\n首先3个class不用说了\n\n```javascript\n\nhasClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].className.match(reg)) return true;\n\n            return false;\n\n    }\n\n    return this;\n\n},\n\n```\n\n<!-- more -->\n\n```javascript\naddClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    for (var i = 0; i < this.length; i++) {\n\n        if(!this[i].className.match(reg))\n\n            this[i].className += ' ' + cls;\n\n    }\n\n    return this;\n\n},\n```\n\n\n\n```javascript\n\nremoveClass : function(cls) {\n\n    var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\n    for (var i = 0; i < this.length; i++) {\n\n        if (this[i].className.match(reg))\n\n            this[i].className = this[i].className.replace(' ' + cls,'');\n\n    }\n\n    return this;\n\n}\n\n```\n\n<!-- more -->\n\n然后新增一个\n\n```javascript\n\ncss : function(attr,val) { // 链式测试\n\n    console.log(this.length);\n\n    for(var i = 0;i < this.length; i++) {\n\n        if(arguments.length == 1) {\n\n            return getComputedStyle(this[i],null)[attr];\n\n        }\n\n        this[i].style[attr] = val;\n\n    }\n\n    return this;\n\n}\n\n```\n\n\n\n这些其实都很简单,我们都要记住,我们封装的DOM对象是一个数组,所以一定都需要用循环来进行各种个样的处理\n\n\n\n然后css这我是用 `arguments` 的个数来进行判断是取值还是设值\n\n\n\n最后千万别忘了每个方法的最后都要 `return this` 以便链式调用\n\n\n\n大家可以自行拿这几个方法 log出来看看是否是与jQuery的一样就知道是否成功了\n","slug":"jquery02","published":1,"updated":"2015-11-23T12:20:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit64000gzp8gm86a1pa4"},{"title":"可想实现一个自己的简单jQuery库？(一)","date":"2015-11-18T12:26:48.000Z","_content":"\n## 前言\n\n1. 虽然说市面上有许多讲解jQuery源码或者是也有类似如何搭建一个属于自己的javascript库的文章。\n\n2. 但毕竟更多数人的水平并没有达到单纯看源码解析就能读懂jQuery\n\n3. 如果你既不能通过书籍视频和他人文章的源码解析明白jQuery，也想自己实现一个jQuery的。\n\n4. 本系列就是以一些不同的方法手段，简单的代码，实现了一套与jQuery一样的API\n\n<!-- more -->\n\n## Lesson-0\n\n首先第一个版本,我们要先了解搭建一个库或者是一个给别人使用的小插件应该用一种什么样的格式.\n\n\n\n首先我们需要创建一个闭包\n\n```javascript\n\n(function()){\n\n    //code..\n\n}();\n\n```\n\n然后将我们所需要的代码和逻辑都写在里面避免全局变量的泛滥.\n\n\n\n接着我们来看看我们第一版里的代码.\n\n```javascript\n\n(function(window,document) {\n\n    var w = window,\n\n        doc = document;\n\n    var Kodo = function(selector) {\n\n        return new Kodo.prototype.init(selector);\n\n    }\n\n    Kodo.prototype = {\n\n        constructor : Kodo,\n\n        length : 0,\n\n        splice: [].splice,\n\n        selector : '',\n\n        init : function(selector) {//dom选择的一些判断\n\n\n\n        }\n\n    }\n\n    Kodo.prototype.init.prototype = Kodo.prototype;\n\n\n\n    Kodo.ajax = function() { //直接挂载方法  可k.ajax调用\n\n        console.log(this);\n\n    }\n\n\n\n    window.f = Kodo;\n\n})(window,document);\n\n```\n\n\n\n我创建了一个闭包,传入了window,document并且在内部将他们缓存起来.\n\n\n\n接着\n\n```javascript\n\nvar kodo = function(selector) {\n\n    return new Kodo.prototype.init(selector);\n\n}\n\n```\n\n\n\n如果有看过jQuery源码的童鞋对这个真是在了解不过了.每次用kodo调用的时候,将直接 返回一个kodo的实例.达到无new调用的效果\n\n```javascript\n\nKodo.prototype = {\n\n    constructor : Kodo,\n\n    length : 0,\n\n    splice: [].splice,\n\n    selector : '',\n\n    init : function(selector) {//dom选择的一些判断\n\n\n\n    }\n\n}\n\nKodo.prototype.init.prototype = Kodo.prototype;\n\n```\n\n\n\n接着重点就在于如何去构造Kodo的prototype的原型了.在这上面的属性也就相当于是jQuery的实例方法和属性.所以每次$()后都能链式调用.\n\n\n\n由于我们是return new Kodo.prototype.init,那自然,我们需要手动的把init的prototype指向Kodo的prototype\n\n\n\n同时我们在原型上具有splice属性后,我们的对象就会变为了一个类数组对象,神奇吧!\n\n```javascript\n\nKodo.ajax = function() { //直接挂载方法  可f.ajax调用\n\n    console.log(this);\n\n}\n\n```\n\n\n\n由于javascript中一切皆对象,所以我们能在我们的Kodo上直接用.XXX来赋予新的属性和方法,这样的方法也被称之为静态方法.\n\n```javascript\n\nwindow.f = Kodo;\n\n```\n\n\n\n最后我们在window上对外暴露一个接口,我们就可以愉快的用 f.ajax 或者是 f(\"#id\")即可调用.","source":"_posts/jquery01.md","raw":"title: 可想实现一个自己的简单jQuery库？(一)\ndate: 2015-11-18 20:26:48\ntags:\n---\n\n## 前言\n\n1. 虽然说市面上有许多讲解jQuery源码或者是也有类似如何搭建一个属于自己的javascript库的文章。\n\n2. 但毕竟更多数人的水平并没有达到单纯看源码解析就能读懂jQuery\n\n3. 如果你既不能通过书籍视频和他人文章的源码解析明白jQuery，也想自己实现一个jQuery的。\n\n4. 本系列就是以一些不同的方法手段，简单的代码，实现了一套与jQuery一样的API\n\n<!-- more -->\n\n## Lesson-0\n\n首先第一个版本,我们要先了解搭建一个库或者是一个给别人使用的小插件应该用一种什么样的格式.\n\n\n\n首先我们需要创建一个闭包\n\n```javascript\n\n(function()){\n\n    //code..\n\n}();\n\n```\n\n然后将我们所需要的代码和逻辑都写在里面避免全局变量的泛滥.\n\n\n\n接着我们来看看我们第一版里的代码.\n\n```javascript\n\n(function(window,document) {\n\n    var w = window,\n\n        doc = document;\n\n    var Kodo = function(selector) {\n\n        return new Kodo.prototype.init(selector);\n\n    }\n\n    Kodo.prototype = {\n\n        constructor : Kodo,\n\n        length : 0,\n\n        splice: [].splice,\n\n        selector : '',\n\n        init : function(selector) {//dom选择的一些判断\n\n\n\n        }\n\n    }\n\n    Kodo.prototype.init.prototype = Kodo.prototype;\n\n\n\n    Kodo.ajax = function() { //直接挂载方法  可k.ajax调用\n\n        console.log(this);\n\n    }\n\n\n\n    window.f = Kodo;\n\n})(window,document);\n\n```\n\n\n\n我创建了一个闭包,传入了window,document并且在内部将他们缓存起来.\n\n\n\n接着\n\n```javascript\n\nvar kodo = function(selector) {\n\n    return new Kodo.prototype.init(selector);\n\n}\n\n```\n\n\n\n如果有看过jQuery源码的童鞋对这个真是在了解不过了.每次用kodo调用的时候,将直接 返回一个kodo的实例.达到无new调用的效果\n\n```javascript\n\nKodo.prototype = {\n\n    constructor : Kodo,\n\n    length : 0,\n\n    splice: [].splice,\n\n    selector : '',\n\n    init : function(selector) {//dom选择的一些判断\n\n\n\n    }\n\n}\n\nKodo.prototype.init.prototype = Kodo.prototype;\n\n```\n\n\n\n接着重点就在于如何去构造Kodo的prototype的原型了.在这上面的属性也就相当于是jQuery的实例方法和属性.所以每次$()后都能链式调用.\n\n\n\n由于我们是return new Kodo.prototype.init,那自然,我们需要手动的把init的prototype指向Kodo的prototype\n\n\n\n同时我们在原型上具有splice属性后,我们的对象就会变为了一个类数组对象,神奇吧!\n\n```javascript\n\nKodo.ajax = function() { //直接挂载方法  可f.ajax调用\n\n    console.log(this);\n\n}\n\n```\n\n\n\n由于javascript中一切皆对象,所以我们能在我们的Kodo上直接用.XXX来赋予新的属性和方法,这样的方法也被称之为静态方法.\n\n```javascript\n\nwindow.f = Kodo;\n\n```\n\n\n\n最后我们在window上对外暴露一个接口,我们就可以愉快的用 f.ajax 或者是 f(\"#id\")即可调用.","slug":"jquery01","published":1,"updated":"2015-11-23T12:22:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit66000hzp8gh8ycnk2b"},{"title":"Hello World","date":"2014-10-17T12:55:32.000Z","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/rehufa/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.2\"></script>\n","source":"_posts/hello-world.md","raw":"title: Hello World\ndate: 2014-10-17 20:55:32\ntags: hello\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/rehufa/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.2\"></script>\n","slug":"hello-world","published":1,"updated":"2015-11-03T13:05:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit69000izp8g7dl1zjr0"},{"title":"前端工程化知识要点回顾&思考","date":"2015-11-16T12:24:27.000Z","_content":"\n## 编程技术及生态发展的三个阶段\n\n* 最初的时候人们忙着补全各种API，代表着他们拥有的东西还很匮乏，需要在语言跟基础设施上继续完善\n\n* 然后就开始各种模式，标志他们做的东西逐渐变大变复杂，需要更好的组织了\n\n* 然后就是各类分层MVC，MVP，MVVM之类，可视化开发，自动化测试，团队协同系统等等，说明重视生产效率了，也就是所谓工程化\n\n\n\n## 前端工程是软件工程的一个子类别\n\n软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。\n\n<!-- more --> \n\n## 前端是一种GUI软件\n\n> 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。\n\n\n\n前端又不同于传统的客户端软件／后端，因为前端应用具备“免安装”、“增量安装”等特性。也“得益”于这些特性，前端应用会遭遇客户端应用不可能碰到的资源管理问题，这也是前端最容易引起工程问题的点。\n\n\n\n## 一个符合工程化要求的软件系统(前端)需要包含的要素\n\n1. 开发规范\n\n2. 模块化开发\n\n3. 组件化开发\n\n4. 组件仓库\n\n5. 性能优化\n\n6. 项目部署\n\n7. 开发流程\n\n8. 开发工具\n\n\n\n1-3是技术业务相关的开发需求，4是技术沉淀及共享需求，5-8是工程优化需求\n\n> 大部分时候我们谈的“工程化”其实只是“工具化”。\n\n\n\n每一个单独的点或许都比较容易实现，但是把这8条串联起来则是一个很大的挑战，而且这8个点相互之间又互有联系\n\n* 模块化开发涉及到性能优化，对构建工具有一定的配套实现要求，同时也会影响开发规范的制定\n\n* 组件化开发应该基于模块化框架来加载其他依赖的组件，如果组件化框架自带模块管理功能，那么就可能导致工程的性能优化实现困难（我们可以直接使用ES6的module语法及loader）\n\n* 组件库应该与组件化开发配套，组件仓库中的组件应该按照相同的标准实现\n\n* 开发规范工具必须容易实现，如果部署上有特殊要求，工具是否能很容易的做出调整而不是修改规范\n\n* 工具是否能提供接入公司已有流程的接口，是否能与公司的ci工具相互融合\n\n\n\n## 为什么都说前端目前正遭遇前所未有的工程问题\n\n1. 前端在第1、2阶段耗费了十多年的时间，然后近几年才井喷式的爆发\n\n2. 由于整个生态的发展缓慢、门槛低、构建应用成本低，前端开发长时间停留在刀耕火种、茹毛饮血的阶段\n\n3. 以前大部分前端工作都是切页面加特效，还不能算得上一个真正意义上的webapp，自然很少有公司能遭遇到工程化问题\n\n4. 前端不同于 客户端／后端 的特性(比如增量安装)，导致遭遇的工程会很特殊，很难直接从别的领域套用已有的解决方案\n\n5. 我们自己完全意识不到那是问题\n\n\n\n## 工程化到底要解决哪些问题\n\n1. 合理的开发流程及开发规范，包括代码规范、模块化组件化规范(分治)等（提高生产力）\n\n2. 一套自动化代码质量检测方案（提高系统可靠性）\n\n3. 一套自动化及高度适应性的项目 发布／部署 方案（提高系统的伸缩性及灵活性）\n\n4. 极致的性能优化，包括减少冗余的接口请求及资源请求、提高缓存命中率等，简言之就是站点的打开及运行速度（更好的用户体验）\n\n\n\n举三个案例：\n\n\n\n1. 最基本的资源合并，我们应该采取哪种策略？全部打包成一个还是分开打包？如何最高效的利用缓存？如何在降低请求数的同时提高缓存利用率？移动终端又应该采取哪种策略？\n\n2. 发布的时候我们到底是应该先部署页面还是静态资源？如何实现平滑升级？如果我还想玩个灰度发布呢？\n\n3. 如果采用模块化按需加载的方式开发，每次发布资源文件都会有不同的md5值，如何在不影响开发体验的前提下确保能引用到正确的模块？\n\n\n\n## 相关工具\n\n1. 构建工具 gulp \n\ntask-based的方式使得gulp无法(难以)处理资源嵌套的递归场景。如 a.js -> b.scss -> md5(d.img) -> md5(b.scss) -> md5(a.js)\n\n2. 基于 资源表＋资源管理框架 策略的 [fis](https://github.com/fex-team/fis) \n\n其实已经能处理大部分场景了，但是侵入式代码实在是无法接受。因为它是一个框架。\n\n3. 静态分析工具 webpack\n\nwebpack依赖其可配置的loader使其拥有强大的打包能力，但是依然无法实现动态按需加载的需求。类似：\n\n```javascript\n\nif(browser){\n\n    require('browser.js');\n\n} else {\n\n    require('node.js');\n\n}\n\n```\n\n\n\n## 出路\n\n> *ES6 Module ＋ ES6 Module Loader ＋ HTTP2.0 ＋ Others*\n\n\n\nES6 Module提供了一个原生的模块化语法，ES6 Module Loader则能提供一个原生的模块加载器。对于前端工程而言，资源管理是最核心的问题，而资源管理中加载又是重点更是难点。\n\n\n\n可是ES6 Module Loader从ES6草案中移除了现在由WHATWG组织还在维护制定标准，pending状态。。 现在有一个基于这个草案实现的api polyfill [Module Loader](https://github.com/ModuleLoader/es6-module-loader)。可是你不是规范我这种教条主义者是不会用的\n\n\n\n## 总结\n\n前端工程化相关问题是随之前端的发展越来越受到重视的问题，一套好的工程化解决方案能在提高开发效率(包括代码编写的舒适度及多人协作)的同时确保整个系统的伸缩性(各种不同的部署环境)及健壮性(安全)，同时在性能上又能有一个很优异的表现(主要上各种缓存策略加载策略等)，而且这套方案又应该是对工程师无感知(或感知很小)趋于自动化的一套方案。总知要达到这个目的前端工程化还有很长一段路要走。\n\n\n\n## 拓展阅读\n\n1. 国内工程化第一人系列文章 [https://github.com/fouber/blog/issues](https://github.com/fouber/blog/issues)\n\n2. [大公司是如何部署前端代码的](https://github.com/fouber/blog/issues/6)\n\n3. 相关工具\n\n  * 百度：[fis](https://github.com/fex-team/fis) （资源表＋资源管理框架 策略）\n\n  * UC：[scrat](https://github.com/scrat-team/scrat)\n\n  * 腾讯：[mtjs](http://mtjs.github.io/) （可以实现字节增量发布）","source":"_posts/front-end1.md","raw":"title: 前端工程化知识要点回顾&思考\ndate: 2015-11-16 20:24:27\ntags:\n---\n\n## 编程技术及生态发展的三个阶段\n\n* 最初的时候人们忙着补全各种API，代表着他们拥有的东西还很匮乏，需要在语言跟基础设施上继续完善\n\n* 然后就开始各种模式，标志他们做的东西逐渐变大变复杂，需要更好的组织了\n\n* 然后就是各类分层MVC，MVP，MVVM之类，可视化开发，自动化测试，团队协同系统等等，说明重视生产效率了，也就是所谓工程化\n\n\n\n## 前端工程是软件工程的一个子类别\n\n软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。\n\n<!-- more --> \n\n## 前端是一种GUI软件\n\n> 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。\n\n\n\n前端又不同于传统的客户端软件／后端，因为前端应用具备“免安装”、“增量安装”等特性。也“得益”于这些特性，前端应用会遭遇客户端应用不可能碰到的资源管理问题，这也是前端最容易引起工程问题的点。\n\n\n\n## 一个符合工程化要求的软件系统(前端)需要包含的要素\n\n1. 开发规范\n\n2. 模块化开发\n\n3. 组件化开发\n\n4. 组件仓库\n\n5. 性能优化\n\n6. 项目部署\n\n7. 开发流程\n\n8. 开发工具\n\n\n\n1-3是技术业务相关的开发需求，4是技术沉淀及共享需求，5-8是工程优化需求\n\n> 大部分时候我们谈的“工程化”其实只是“工具化”。\n\n\n\n每一个单独的点或许都比较容易实现，但是把这8条串联起来则是一个很大的挑战，而且这8个点相互之间又互有联系\n\n* 模块化开发涉及到性能优化，对构建工具有一定的配套实现要求，同时也会影响开发规范的制定\n\n* 组件化开发应该基于模块化框架来加载其他依赖的组件，如果组件化框架自带模块管理功能，那么就可能导致工程的性能优化实现困难（我们可以直接使用ES6的module语法及loader）\n\n* 组件库应该与组件化开发配套，组件仓库中的组件应该按照相同的标准实现\n\n* 开发规范工具必须容易实现，如果部署上有特殊要求，工具是否能很容易的做出调整而不是修改规范\n\n* 工具是否能提供接入公司已有流程的接口，是否能与公司的ci工具相互融合\n\n\n\n## 为什么都说前端目前正遭遇前所未有的工程问题\n\n1. 前端在第1、2阶段耗费了十多年的时间，然后近几年才井喷式的爆发\n\n2. 由于整个生态的发展缓慢、门槛低、构建应用成本低，前端开发长时间停留在刀耕火种、茹毛饮血的阶段\n\n3. 以前大部分前端工作都是切页面加特效，还不能算得上一个真正意义上的webapp，自然很少有公司能遭遇到工程化问题\n\n4. 前端不同于 客户端／后端 的特性(比如增量安装)，导致遭遇的工程会很特殊，很难直接从别的领域套用已有的解决方案\n\n5. 我们自己完全意识不到那是问题\n\n\n\n## 工程化到底要解决哪些问题\n\n1. 合理的开发流程及开发规范，包括代码规范、模块化组件化规范(分治)等（提高生产力）\n\n2. 一套自动化代码质量检测方案（提高系统可靠性）\n\n3. 一套自动化及高度适应性的项目 发布／部署 方案（提高系统的伸缩性及灵活性）\n\n4. 极致的性能优化，包括减少冗余的接口请求及资源请求、提高缓存命中率等，简言之就是站点的打开及运行速度（更好的用户体验）\n\n\n\n举三个案例：\n\n\n\n1. 最基本的资源合并，我们应该采取哪种策略？全部打包成一个还是分开打包？如何最高效的利用缓存？如何在降低请求数的同时提高缓存利用率？移动终端又应该采取哪种策略？\n\n2. 发布的时候我们到底是应该先部署页面还是静态资源？如何实现平滑升级？如果我还想玩个灰度发布呢？\n\n3. 如果采用模块化按需加载的方式开发，每次发布资源文件都会有不同的md5值，如何在不影响开发体验的前提下确保能引用到正确的模块？\n\n\n\n## 相关工具\n\n1. 构建工具 gulp \n\ntask-based的方式使得gulp无法(难以)处理资源嵌套的递归场景。如 a.js -> b.scss -> md5(d.img) -> md5(b.scss) -> md5(a.js)\n\n2. 基于 资源表＋资源管理框架 策略的 [fis](https://github.com/fex-team/fis) \n\n其实已经能处理大部分场景了，但是侵入式代码实在是无法接受。因为它是一个框架。\n\n3. 静态分析工具 webpack\n\nwebpack依赖其可配置的loader使其拥有强大的打包能力，但是依然无法实现动态按需加载的需求。类似：\n\n```javascript\n\nif(browser){\n\n    require('browser.js');\n\n} else {\n\n    require('node.js');\n\n}\n\n```\n\n\n\n## 出路\n\n> *ES6 Module ＋ ES6 Module Loader ＋ HTTP2.0 ＋ Others*\n\n\n\nES6 Module提供了一个原生的模块化语法，ES6 Module Loader则能提供一个原生的模块加载器。对于前端工程而言，资源管理是最核心的问题，而资源管理中加载又是重点更是难点。\n\n\n\n可是ES6 Module Loader从ES6草案中移除了现在由WHATWG组织还在维护制定标准，pending状态。。 现在有一个基于这个草案实现的api polyfill [Module Loader](https://github.com/ModuleLoader/es6-module-loader)。可是你不是规范我这种教条主义者是不会用的\n\n\n\n## 总结\n\n前端工程化相关问题是随之前端的发展越来越受到重视的问题，一套好的工程化解决方案能在提高开发效率(包括代码编写的舒适度及多人协作)的同时确保整个系统的伸缩性(各种不同的部署环境)及健壮性(安全)，同时在性能上又能有一个很优异的表现(主要上各种缓存策略加载策略等)，而且这套方案又应该是对工程师无感知(或感知很小)趋于自动化的一套方案。总知要达到这个目的前端工程化还有很长一段路要走。\n\n\n\n## 拓展阅读\n\n1. 国内工程化第一人系列文章 [https://github.com/fouber/blog/issues](https://github.com/fouber/blog/issues)\n\n2. [大公司是如何部署前端代码的](https://github.com/fouber/blog/issues/6)\n\n3. 相关工具\n\n  * 百度：[fis](https://github.com/fex-team/fis) （资源表＋资源管理框架 策略）\n\n  * UC：[scrat](https://github.com/scrat-team/scrat)\n\n  * 腾讯：[mtjs](http://mtjs.github.io/) （可以实现字节增量发布）","slug":"front-end1","published":1,"updated":"2015-11-16T12:26:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgvit6h000lzp8gjwyucqw4"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cijgvit69000izp8g7dl1zjr0","tag_id":"cijgvit6a000jzp8gwsq6cfuq","_id":"cijgvit6g000kzp8gsvbe38ef"}],"Tag":[{"name":"hello","_id":"cijgvit6a000jzp8gwsq6cfuq"}]}}